{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperlinked Twin","text":"<p>This website is a hyperlinked twin of a Spoofax language project code repository. The website navigation hierarchy corresponds to the repository file hierarchy, and the code displayed on each page is a verbatim copy of the raw code in the corresponding file.</p> <p>Hyperlinked twins support precise name-based code navigation online in ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the first declaration of the name.</li> <li>Click on a declaration to display a modal with links to all the references to the declaration.<sup>1</sup></li> </ul> <p>The sources of the webpages were generated using Spoofax from the analysed language project. The hyperlinks added to names were generated from the name binding analysis used by Spoofax, and the syntax highlighting corresponds closely to that displayed when browsing files in Spoofax.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twin websites with code in all Spoofax meta-languages.</p> <ol> <li> <p>When there is only one reference to a declaration, \u200b    clicking on the declaration jumps directly to the reference. \u200b    When there are no references to a declaration, \u200b    clicking on it has no effect.\u00a0\u21a9</p> </li> </ol>"},{"location":"org.metaborg.lang.poosl/","title":"POOSL","text":"<p> metaborgcube/metaborg-poosl/org.metaborg.lang.poosl</p> <p>From the repository README:</p> <p>POOSL is an abbreviation of Parallel Object-Oriented Specification Language. This language originates from research at Eindhoven University of Technology:</p> <ul> <li>P.H.A. van der Putten, and J.P.M. Voeten, \"Specification of Reactive Hardware/Software Systems: The Method Software/Hardware Engineering (SHE)\", Ph.D. thesis, Eindhoven University of Technology, 1997. https://doi.org/10.6100/IR491299</li> <li>L. van Bokhoven, \"Constructive Tool Design for Formal Languages; From Semantics to Executing Models\", Ph.D. thesis, Eindhoven University of Technology, 2004. https://doi.org/10.6100/IR559665</li> </ul> <p>The main toolset for POOSL consists of textual and graphical editors, a command-line simulator, and an interactive debugging environment; this toolset is available at https://www.poosl.org/</p>"},{"location":"org.metaborg.lang.poosl/#reference","title":"Reference","text":"<p>[...] The type checker is documented in the following article:</p> <ul> <li>A.J. Mooij, \"Static type checking without downcast operator\", Information Processing Letters, Volume 178, November 2022. https://doi.org/10.1016/j.ipl.2022.106285</li> </ul>"},{"location":"org.metaborg.lang.poosl/#syntax","title":"Syntax","text":"<p><code>syntax/Poosl.sdf3</code></p> <p>The syntax of Poosl is specified in SDF3.</p>"},{"location":"org.metaborg.lang.poosl/#name-binding","title":"Name binding","text":"<p><code>trans/statics.stx</code></p> <p>The name binding of Poosl is specified in Statix.</p>"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Common-sig.stx/","title":"<code>Common-sig.stx</code>","text":"<pre><code>module signatures/Common-sig\n\nimports\n\nsignature\n\n  sorts\n    ID = string\n    ENV = string\n    BOOL = string\n    INT = string\n    REAL = string\n    FLOAT = string\n    EXP = string\n    REAL_CORE_NE = string\n    INT_CORE_NE = string\n    REAL_CORE = string\n    INT_CORE = string\n    BIN_CORE = string\n    HEX_CORE = string\n    ZERO = string\n    STRING = string\n    CHARACTER = string\n    STRING_CHAR = string\n    CHARACTER_CHAR = string\n    ESCAPE_SEQUENCE = string\n    ESCAPE_ZERO = string\n    BACKSLASH_CHAR = string\n    ML_COM = string\n    LONESTAR = string\n    EOF = string\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Common-sig.stx/#modal-h2","title":"Common-sig.stx","text":""},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/ExprStat-sig.stx/","title":"<code>ExprStat-sig.stx</code>","text":"<pre><code>module signatures/ExprStat-sig\n\nimports\n  signatures/Common-sig\n\nsignature\n\n  sorts\n    Statement\n    SingleStatement\n    AndStatement\n    OrStatement\n    ProcessMethodCall\n    CaseStatementList\n    CaseStatement\n    OptDefaultStatement\n    Expression\n    SingleExpression\n    OnSuperClass\n    OptExpressionList\n    OptVariableList\n    ExpressionList\n    CaseExpressionList\n    CaseExpression\n    OptDefaultExpression\n    ExpressionConstant\n    UnaryOperator\n    BinaryOperatorLevel2\n    BinaryOperatorLevel3\n    BinaryOperatorLevel4\n    VariableList\n    OptPostExpression\n    OptReceptionCondition\n\n  constructors\n    Statement-Plhdr : Statement\n    SingleStatement-Plhdr : SingleStatement\n    AndStatement-Plhdr : AndStatement\n    OrStatement-Plhdr : OrStatement\n    ProcessMethodCall-Plhdr : ProcessMethodCall\n    CaseStatementList-Plhdr : CaseStatementList\n    CaseStatement-Plhdr : CaseStatement\n    OptDefaultStatement-Plhdr : OptDefaultStatement\n    Expression-Plhdr : Expression\n    SingleExpression-Plhdr : SingleExpression\n    OnSuperClass-Plhdr : OnSuperClass\n    OptExpressionList-Plhdr : OptExpressionList\n    OptVariableList-Plhdr : OptVariableList\n    ExpressionList-Plhdr : ExpressionList\n    CaseExpressionList-Plhdr : CaseExpressionList\n    CaseExpression-Plhdr : CaseExpression\n    OptDefaultExpression-Plhdr : OptDefaultExpression\n    ExpressionConstant-Plhdr : ExpressionConstant\n    UnaryOperator-Plhdr : UnaryOperator\n    BinaryOperatorLevel2-Plhdr : BinaryOperatorLevel2\n    BinaryOperatorLevel3-Plhdr : BinaryOperatorLevel3\n    BinaryOperatorLevel4-Plhdr : BinaryOperatorLevel4\n    VariableList-Plhdr : VariableList\n    OptPostExpression-Plhdr : OptPostExpression\n    OptReceptionCondition-Plhdr : OptReceptionCondition\n\nsignature\n\n  constructors\n    StatementSequence : list(SingleStatement) -&gt; Statement\n    AbortStatement : Statement * SingleStatement -&gt; SingleStatement\n    DelayStatement : SingleExpression -&gt; SingleStatement\n    GuardedStatement : Expression * SingleStatement -&gt; SingleStatement\n    InterruptStatement : Statement * SingleStatement -&gt; SingleStatement\n    ParStatement : Statement * list(AndStatement) -&gt; SingleStatement\n    ProcessMethodCallStatement : ProcessMethodCall -&gt; SingleStatement\n    SelStatement : Statement * list(OrStatement) -&gt; SingleStatement\n    SkipStatement : SingleStatement\n    SendStatement : ID * ID * OptExpressionList * OptPostExpression -&gt; SingleStatement\n    ReceiveStatement : ID * ID * OptVariableList * OptReceptionCondition * OptPostExpression -&gt; SingleStatement\n    IfThenStatement : Expression * Statement -&gt; SingleStatement\n    IfThenElseStatement : Expression * Statement * Statement -&gt; SingleStatement\n    RoundBracketStatement : Statement -&gt; SingleStatement\n    WhileStatement : Expression * Statement -&gt; SingleStatement\n    SwitchStatement : Expression * CaseStatementList * OptDefaultStatement -&gt; SingleStatement\n    ExpressionStatement : SingleExpression -&gt; SingleStatement\n    CurlyExpressionStatement : Expression -&gt; SingleStatement\n    ProcessMethodCall : ID * ExpressionList * VariableList -&gt; ProcessMethodCall\n    AndStatement : Statement -&gt; AndStatement\n    OrStatement : Statement -&gt; OrStatement\n    CaseStatementList : list(CaseStatement) -&gt; CaseStatementList\n    CaseStatement : Expression * Statement -&gt; CaseStatement\n    DefaultStatement : Statement -&gt; OptDefaultStatement\n    NoDefaultStatement : OptDefaultStatement\n    PostExpression : Expression -&gt; OptPostExpression\n    NoPostExpression : OptPostExpression\n    ReceptionCondition : Expression -&gt; OptReceptionCondition\n    NoReceptionCondition : OptReceptionCondition\n    Variables : list(ID) -&gt; OptVariableList\n    NoVariables : OptVariableList\n    VariableList : list(ID) -&gt; VariableList\n    ExpressionSequence : list(SingleExpression) -&gt; Expression\n    AssignmentExpression : ID * SingleExpression -&gt; SingleExpression\n    ReturnExpression : SingleExpression -&gt; SingleExpression\n    BinaryOperatorExpression2 : SingleExpression * BinaryOperatorLevel2 * SingleExpression -&gt; SingleExpression\n    BinaryOperatorExpression3 : SingleExpression * BinaryOperatorLevel3 * SingleExpression -&gt; SingleExpression\n    BinaryOperatorExpression4 : SingleExpression * BinaryOperatorLevel4 * SingleExpression -&gt; SingleExpression\n    DataMethodCallExpression : SingleExpression * OnSuperClass * ID * OptExpressionList -&gt; SingleExpression\n    UnaryOperatorExpression : UnaryOperator * SingleExpression -&gt; SingleExpression\n    IfThenExpression : Expression * Expression -&gt; SingleExpression\n    IfThenElseExpression : Expression * Expression * Expression -&gt; SingleExpression\n    WhileExpression : Expression * Expression -&gt; SingleExpression\n    SwitchExpression : Expression * CaseExpressionList * OptDefaultExpression -&gt; SingleExpression\n    CurrentTimeExpression : SingleExpression\n    SelfExpression : SingleExpression\n    ConstantExpression : ExpressionConstant -&gt; SingleExpression\n    NewExpression : ID -&gt; SingleExpression\n    VariableExpression : ID -&gt; SingleExpression\n    RoundBracketExpression : Expression -&gt; SingleExpression\n    BooleanConstant : BOOL -&gt; ExpressionConstant\n    CharacterConstant : CHARACTER -&gt; ExpressionConstant\n    FloatConstant : FLOAT -&gt; ExpressionConstant\n    IntegerConstant : INT -&gt; ExpressionConstant\n    NilConstant : ExpressionConstant\n    RealConstant : REAL -&gt; ExpressionConstant\n    StringConstant : STRING -&gt; ExpressionConstant\n    EnvironmentConstant : ENV -&gt; ExpressionConstant\n    OnSuperClass : OnSuperClass\n    NotOnSuperClass : OnSuperClass\n    Expressions : list(Expression) -&gt; OptExpressionList\n    NoExpressions : OptExpressionList\n    ExpressionList : list(Expression) -&gt; ExpressionList\n    CaseExpressionList : list(CaseExpression) -&gt; CaseExpressionList\n    CaseExpression : Expression * Expression -&gt; CaseExpression\n    DefaultExpression : Expression -&gt; OptDefaultExpression\n    NoDefaultExpression : OptDefaultExpression\n    Minus : UnaryOperator\n    Not : UnaryOperator\n    Equal : BinaryOperatorLevel2\n    Unequal : BinaryOperatorLevel2\n    Identical : BinaryOperatorLevel2\n    NotIdentical : BinaryOperatorLevel2\n    LessThan : BinaryOperatorLevel2\n    AtMost : BinaryOperatorLevel2\n    GreaterThan : BinaryOperatorLevel2\n    AtLeast : BinaryOperatorLevel2\n    Add : BinaryOperatorLevel3\n    Subtract : BinaryOperatorLevel3\n    And : BinaryOperatorLevel3\n    Or : BinaryOperatorLevel3\n    Multiply : BinaryOperatorLevel4\n    Divide : BinaryOperatorLevel4\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/ExprStat-sig.stx/#modal-h2","title":"ExprStat-sig.stx","text":""},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Poosl-sig.stx/","title":"<code>Poosl-sig.stx</code>","text":"<pre><code>module signatures/Poosl-sig\n\nimports\n  signatures/Common-sig\n  signatures/ExprStat-sig\n\nsignature\n\n  sorts\n    Poosl\n    ImportList\n    Import\n    AnnotationList\n    Annotation\n    OptAnnotationArgs\n    Class\n    ClassList\n    DataMethodList\n    DataMethod\n    OperatorBinary\n    NativeClause\n    ExtendsClause\n    IDList\n    Declaration\n    DeclarationOptCommaList\n    DeclarationOptComma\n    ParameterList\n    OptEmptyList\n    OptParameterList\n    OptLocalVariableList\n    ProcessMethodList\n    ProcessMethod\n    PortList\n    Port\n    MessageSignatureList\n    MessageSignature\n    OptMessageParameterList\n    InstanceList\n    Instance\n    OptInstanceParameterList\n    InstanceParameter\n    ChannelList\n    Channel\n    PortInstance\n    PortInstanceList\n    OptionalComma\n\n  constructors\n    Poosl-Plhdr : Poosl\n    ImportList-Plhdr : ImportList\n    Import-Plhdr : Import\n    AnnotationList-Plhdr : AnnotationList\n    Annotation-Plhdr : Annotation\n    OptAnnotationArgs-Plhdr : OptAnnotationArgs\n    Class-Plhdr : Class\n    ClassList-Plhdr : ClassList\n    DataMethodList-Plhdr : DataMethodList\n    DataMethod-Plhdr : DataMethod\n    OperatorBinary-Plhdr : OperatorBinary\n    NativeClause-Plhdr : NativeClause\n    ExtendsClause-Plhdr : ExtendsClause\n    IDList-Plhdr : IDList\n    Declaration-Plhdr : Declaration\n    DeclarationOptCommaList-Plhdr : DeclarationOptCommaList\n    DeclarationOptComma-Plhdr : DeclarationOptComma\n    ParameterList-Plhdr : ParameterList\n    OptEmptyList-Plhdr : OptEmptyList\n    OptParameterList-Plhdr : OptParameterList\n    OptLocalVariableList-Plhdr : OptLocalVariableList\n    ProcessMethodList-Plhdr : ProcessMethodList\n    ProcessMethod-Plhdr : ProcessMethod\n    PortList-Plhdr : PortList\n    Port-Plhdr : Port\n    MessageSignatureList-Plhdr : MessageSignatureList\n    MessageSignature-Plhdr : MessageSignature\n    OptMessageParameterList-Plhdr : OptMessageParameterList\n    InstanceList-Plhdr : InstanceList\n    Instance-Plhdr : Instance\n    OptInstanceParameterList-Plhdr : OptInstanceParameterList\n    InstanceParameter-Plhdr : InstanceParameter\n    ChannelList-Plhdr : ChannelList\n    Channel-Plhdr : Channel\n    PortInstance-Plhdr : PortInstance\n    PortInstanceList-Plhdr : PortInstanceList\n    OptionalComma-Plhdr : OptionalComma\n\nsignature\n\n  constructors\n    Poosl : ImportList * ClassList -&gt; Poosl\n    ImportList : list(Import) -&gt; ImportList\n    ClassList : list(Class) -&gt; ClassList\n    Import : STRING -&gt; Import\n    ImportLib : STRING -&gt; Import\n    AnnotationList : list(Annotation) -&gt; AnnotationList\n    Annotation : ID * OptAnnotationArgs -&gt; Annotation\n    AnnotationArgs : list(ExpressionConstant) -&gt; OptAnnotationArgs\n    NoAnnotationArgs : OptAnnotationArgs\n    DataClass : AnnotationList * NativeClause * ID * ExtendsClause * DeclarationOptCommaList * DataMethodList -&gt; Class\n    DataMethodList : list(DataMethod) -&gt; DataMethodList\n    DataMethodNamed : AnnotationList * ID * OptParameterList * ID * OptLocalVariableList * Expression -&gt; DataMethod\n    DataMethodUnary : AnnotationList * UnaryOperator * OptEmptyList * ID * OptLocalVariableList * Expression -&gt; DataMethod\n    DataMethodBinary : AnnotationList * OperatorBinary * Declaration * ID * OptLocalVariableList * Expression -&gt; DataMethod\n    DataMethodNamedNative : ID * OptParameterList * ID -&gt; DataMethod\n    DataMethodUnaryNative : UnaryOperator * OptEmptyList * ID -&gt; DataMethod\n    DataMethodBinaryNative : OperatorBinary * Declaration * ID -&gt; DataMethod\n    NoList : OptEmptyList\n    EmptyList : OptEmptyList\n    OperatorBinary2 : BinaryOperatorLevel2 -&gt; OperatorBinary\n    OperatorBinary3 : BinaryOperatorLevel3 -&gt; OperatorBinary\n    OperatorBinary4 : BinaryOperatorLevel4 -&gt; OperatorBinary\n    Native : NativeClause\n    NotNative : NativeClause\n    Extends : ID -&gt; ExtendsClause\n    NoExtends : ExtendsClause\n    IDList : list(ID) -&gt; IDList\n    Declaration : IDList * ID -&gt; Declaration\n    DeclarationWithComma : IDList * ID -&gt; DeclarationOptComma\n    DeclarationWithoutComma : IDList * ID -&gt; DeclarationOptComma\n    DeclarationOptCommaList : list(DeclarationOptComma) -&gt; DeclarationOptCommaList\n    ParameterList : list(Declaration) -&gt; ParameterList\n    Parameters : list(Declaration) -&gt; OptParameterList\n    NoParameters : OptParameterList\n    LocalVariables : list(Declaration) -&gt; OptLocalVariableList\n    NoLocalVariables : OptLocalVariableList\n    ProcessClass : AnnotationList * ID * OptParameterList * ExtendsClause * PortList * MessageSignatureList * DeclarationOptCommaList * ProcessMethodCall * ProcessMethodList -&gt; Class\n    ProcessMethodList : list(ProcessMethod) -&gt; ProcessMethodList\n    ProcessMethod : AnnotationList * ID * ParameterList * ParameterList * OptLocalVariableList * Statement -&gt; ProcessMethod\n    PortList : list(Port) -&gt; PortList\n    Port : ID * OptionalComma -&gt; Port\n    MessageSignatureList : list(MessageSignature) -&gt; MessageSignatureList\n    MessageReceiveSignature : ID * ID * OptMessageParameterList * OptionalComma -&gt; MessageSignature\n    MessageSendSignature : ID * ID * OptMessageParameterList * OptionalComma -&gt; MessageSignature\n    MessageParameters : list(ID) -&gt; OptMessageParameterList\n    NoMessageParameters : OptMessageParameterList\n    System : AnnotationList * InstanceList * ChannelList -&gt; Class\n    ClusterClass : AnnotationList * ID * OptParameterList * PortList * InstanceList * ChannelList -&gt; Class\n    InstanceList : list(Instance) -&gt; InstanceList\n    Instance : AnnotationList * ID * ID * OptInstanceParameterList -&gt; Instance\n    InstanceParameters : list(InstanceParameter) -&gt; OptInstanceParameterList\n    NoInstanceParameters : OptInstanceParameterList\n    InstanceParameter : ID * Expression -&gt; InstanceParameter\n    ChannelList : list(Channel) -&gt; ChannelList\n    Channel : AnnotationList * PortInstanceList -&gt; Channel\n    PortInstanceList : list(PortInstance) -&gt; PortInstanceList\n    InternalPort : ID * ID -&gt; PortInstance\n    ExternalPort : ID -&gt; PortInstance\n    Comma : OptionalComma\n    NoComma : OptionalComma\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Poosl-sig.stx/#modal-h2","title":"Poosl-sig.stx","text":""},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Stratego-Poosl-sig.stx/","title":"<code>Stratego-Poosl-sig.stx</code>","text":"<pre><code>module signatures/Stratego-Poosl-sig\n\nimports\n  signatures/StrategoLang/import-namespaced-sig\n  signatures/StrategoLang/sugar/terms-namespaced-sig\n  signatures/StrategoLang/core/modules-namespaced-sig\n  signatures/Poosl-sig\n  signatures/ExprStat-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    StrategoLang-Module2Start : StrategoLang-Module -&gt; Start\n    ToTerm : Poosl -&gt; StrategoLang-PreTerm\n    ToTerm : Poosl -&gt; StrategoLang-PreTerm\n    ToTerm : Import -&gt; StrategoLang-PreTerm\n    ToTerm : Import -&gt; StrategoLang-PreTerm\n    ToTerm : Annotation -&gt; StrategoLang-PreTerm\n    ToTerm : Annotation -&gt; StrategoLang-PreTerm\n    ToTerm : Class -&gt; StrategoLang-PreTerm\n    ToTerm : Class -&gt; StrategoLang-PreTerm\n    ToTerm : DataMethod -&gt; StrategoLang-PreTerm\n    ToTerm : DataMethod -&gt; StrategoLang-PreTerm\n    ToTerm : ProcessMethod -&gt; StrategoLang-PreTerm\n    ToTerm : ProcessMethod -&gt; StrategoLang-PreTerm\n    ToTerm : Port -&gt; StrategoLang-PreTerm\n    ToTerm : Port -&gt; StrategoLang-PreTerm\n    ToTerm : MessageSignature -&gt; StrategoLang-PreTerm\n    ToTerm : MessageSignature -&gt; StrategoLang-PreTerm\n    ToTerm : Instance -&gt; StrategoLang-PreTerm\n    ToTerm : Instance -&gt; StrategoLang-PreTerm\n    ToTerm : Channel -&gt; StrategoLang-PreTerm\n    ToTerm : Channel -&gt; StrategoLang-PreTerm\n    ToTerm : PortInstance -&gt; StrategoLang-PreTerm\n    ToTerm : PortInstance -&gt; StrategoLang-PreTerm\n    ToTerm : Declaration -&gt; StrategoLang-PreTerm\n    ToTerm : Declaration -&gt; StrategoLang-PreTerm\n    ToTerm : Statement -&gt; StrategoLang-PreTerm\n    ToTerm : Statement -&gt; StrategoLang-PreTerm\n    ToTerm : SingleStatement -&gt; StrategoLang-PreTerm\n    ToTerm : SingleStatement -&gt; StrategoLang-PreTerm\n    ToTerm : CaseStatement -&gt; StrategoLang-PreTerm\n    ToTerm : CaseStatement -&gt; StrategoLang-PreTerm\n    ToTerm : Expression -&gt; StrategoLang-PreTerm\n    ToTerm : Expression -&gt; StrategoLang-PreTerm\n    ToTerm : SingleExpression -&gt; StrategoLang-PreTerm\n    ToTerm : SingleExpression -&gt; StrategoLang-PreTerm\n    ToTerm : CaseExpression -&gt; StrategoLang-PreTerm\n    ToTerm : CaseExpression -&gt; StrategoLang-PreTerm\n    FromTerm : StrategoLang-Term -&gt; Poosl\n    FromTerm : StrategoLang-Term -&gt; Poosl\n    FromTerm : StrategoLang-Term -&gt; Import\n    FromTerm : StrategoLang-Term -&gt; Import\n    FromTerm : StrategoLang-Term -&gt; ImportList\n    FromTerm : StrategoLang-Term -&gt; ImportList\n    FromTerm : StrategoLang-Term -&gt; Annotation\n    FromTerm : StrategoLang-Term -&gt; Annotation\n    FromTerm : StrategoLang-Term -&gt; AnnotationList\n    FromTerm : StrategoLang-Term -&gt; AnnotationList\n    FromTerm : StrategoLang-Term -&gt; Class\n    FromTerm : StrategoLang-Term -&gt; Class\n    FromTerm : StrategoLang-Term -&gt; ClassList\n    FromTerm : StrategoLang-Term -&gt; ClassList\n    FromTerm : StrategoLang-Term -&gt; ExtendsClause\n    FromTerm : StrategoLang-Term -&gt; ExtendsClause\n    FromTerm : StrategoLang-Term -&gt; DataMethod\n    FromTerm : StrategoLang-Term -&gt; DataMethod\n    FromTerm : StrategoLang-Term -&gt; DataMethodList\n    FromTerm : StrategoLang-Term -&gt; DataMethodList\n    FromTerm : StrategoLang-Term -&gt; ProcessMethod\n    FromTerm : StrategoLang-Term -&gt; ProcessMethod\n    FromTerm : StrategoLang-Term -&gt; ProcessMethodList\n    FromTerm : StrategoLang-Term -&gt; ProcessMethodList\n    FromTerm : StrategoLang-Term -&gt; ID\n    FromTerm : StrategoLang-Term -&gt; ID\n    FromTerm : StrategoLang-Term -&gt; IDList\n    FromTerm : StrategoLang-Term -&gt; IDList\n    FromTerm : StrategoLang-Term -&gt; OptMessageParameterList\n    FromTerm : StrategoLang-Term -&gt; OptMessageParameterList\n    FromTerm : StrategoLang-Term -&gt; OptVariableList\n    FromTerm : StrategoLang-Term -&gt; OptVariableList\n    FromTerm : StrategoLang-Term -&gt; VariableList\n    FromTerm : StrategoLang-Term -&gt; VariableList\n    FromTerm : StrategoLang-Term -&gt; UnaryOperator\n    FromTerm : StrategoLang-Term -&gt; UnaryOperator\n    FromTerm : StrategoLang-Term -&gt; OperatorBinary\n    FromTerm : StrategoLang-Term -&gt; OperatorBinary\n    FromTerm : StrategoLang-Term -&gt; Declaration\n    FromTerm : StrategoLang-Term -&gt; Declaration\n    FromTerm : StrategoLang-Term -&gt; DeclarationOptComma\n    FromTerm : StrategoLang-Term -&gt; DeclarationOptComma\n    FromTerm : StrategoLang-Term -&gt; DeclarationOptCommaList\n    FromTerm : StrategoLang-Term -&gt; DeclarationOptCommaList\n    FromTerm : StrategoLang-Term -&gt; ParameterList\n    FromTerm : StrategoLang-Term -&gt; ParameterList\n    FromTerm : StrategoLang-Term -&gt; OptParameterList\n    FromTerm : StrategoLang-Term -&gt; OptParameterList\n    FromTerm : StrategoLang-Term -&gt; OptLocalVariableList\n    FromTerm : StrategoLang-Term -&gt; OptLocalVariableList\n    FromTerm : StrategoLang-Term -&gt; OptEmptyList\n    FromTerm : StrategoLang-Term -&gt; OptEmptyList\n    FromTerm : StrategoLang-Term -&gt; Port\n    FromTerm : StrategoLang-Term -&gt; Port\n    FromTerm : StrategoLang-Term -&gt; PortList\n    FromTerm : StrategoLang-Term -&gt; PortList\n    FromTerm : StrategoLang-Term -&gt; MessageSignature\n    FromTerm : StrategoLang-Term -&gt; MessageSignature\n    FromTerm : StrategoLang-Term -&gt; MessageSignatureList\n    FromTerm : StrategoLang-Term -&gt; MessageSignatureList\n    FromTerm : StrategoLang-Term -&gt; Instance\n    FromTerm : StrategoLang-Term -&gt; Instance\n    FromTerm : StrategoLang-Term -&gt; InstanceList\n    FromTerm : StrategoLang-Term -&gt; InstanceList\n    FromTerm : StrategoLang-Term -&gt; Channel\n    FromTerm : StrategoLang-Term -&gt; Channel\n    FromTerm : StrategoLang-Term -&gt; ChannelList\n    FromTerm : StrategoLang-Term -&gt; ChannelList\n    FromTerm : StrategoLang-Term -&gt; InstanceParameter\n    FromTerm : StrategoLang-Term -&gt; InstanceParameter\n    FromTerm : StrategoLang-Term -&gt; OptInstanceParameterList\n    FromTerm : StrategoLang-Term -&gt; OptInstanceParameterList\n    FromTerm : StrategoLang-Term -&gt; PortInstance\n    FromTerm : StrategoLang-Term -&gt; PortInstance\n    FromTerm : StrategoLang-Term -&gt; Statement\n    FromTerm : StrategoLang-Term -&gt; Statement\n    FromTerm : StrategoLang-Term -&gt; SingleStatement\n    FromTerm : StrategoLang-Term -&gt; SingleStatement\n    FromTerm : StrategoLang-Term -&gt; CaseStatement\n    FromTerm : StrategoLang-Term -&gt; CaseStatement\n    FromTerm : StrategoLang-Term -&gt; CaseStatementList\n    FromTerm : StrategoLang-Term -&gt; CaseStatementList\n    FromTerm : StrategoLang-Term -&gt; Expression\n    FromTerm : StrategoLang-Term -&gt; Expression\n    FromTerm : StrategoLang-Term -&gt; SingleExpression\n    FromTerm : StrategoLang-Term -&gt; SingleExpression\n    FromTerm : StrategoLang-Term -&gt; CaseExpression\n    FromTerm : StrategoLang-Term -&gt; CaseExpression\n    FromTerm : StrategoLang-Term -&gt; CaseExpressionList\n    FromTerm : StrategoLang-Term -&gt; CaseExpressionList\n    FromTerm : StrategoLang-Term -&gt; BOOL\n    FromTerm : StrategoLang-Term -&gt; CHARACTER\n    FromTerm : StrategoLang-Term -&gt; FLOAT\n    FromTerm : StrategoLang-Term -&gt; INT\n    FromTerm : StrategoLang-Term -&gt; REAL\n    FromTerm : StrategoLang-Term -&gt; STRING\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/Stratego-Poosl-sig.stx/#modal-h2","title":"Stratego-Poosl-sig.stx","text":""},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/permissive-water-sig.stx/","title":"<code>permissive-water-sig.stx</code>","text":"<pre><code>module signatures/permissive-water-sig\n\nimports\n\nsignature\n\n  sorts\n    WATER = string\n    WATERTOKEN = string\n    WATERTOKENSTART = string\n    WATERTOKENSEPARATOR = string\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/statix/signatures/permissive-water-sig.stx/#modal-h2","title":"permissive-water-sig.stx","text":""},{"location":"org.metaborg.lang.poosl/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"org.metaborg.lang.poosl/syntax/Common.sdf3/","title":"<code>Common.sdf3</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/syntax/Common.sdf3</p> <pre><code>module Common\n\n// --- ID -------\n\nlexical sorts\n  ID ENV\nlexical syntax\n  ID  = [a-zA-Z] [a-zA-Z0-9\\_]*\n  ENV = \"${\" [a-zA-Z0-9\\_]+ \"}\"\nlexical restrictions\n  ID  -/- [a-zA-Z0-9\\_]\n\n\n// --- BOOLEANS -------\n\nlexical sorts\n  BOOL\nlexical syntax\n  BOOL = \"false\"\n  BOOL = \"true\"\nlexical syntax\n  ID   = \"false\" {reject}\n  ID   = \"true\" {reject}\n\n\n// --- NUMBERS -------\n\nlexical sorts\n  INT REAL FLOAT\n  EXP REAL_CORE_NE INT_CORE_NE\n  REAL_CORE INT_CORE BIN_CORE HEX_CORE ZERO\nlexical syntax\n  INT          = [\\-\\+]? (INT_CORE_NE | (INT_CORE EXP) | BIN_CORE | HEX_CORE)\n  REAL         = [\\-\\+]? (REAL_CORE_NE | (REAL_CORE EXP))\n  FLOAT        = [\\-\\+]? ((REAL_CORE_NE [fF]) | (REAL_CORE EXP [fF]) | \"nan\" | \"inf\")\n\n  EXP          = [eE] [\\+]? [0-9]+\n  REAL_CORE_NE = REAL_CORE\n  INT_CORE_NE  = INT_CORE\n\n  REAL_CORE    = INT_CORE \".\" [0-9]* | [0-9]+\n  INT_CORE     = [1-9][0-9]*\n  INT_CORE     = ZERO\n  BIN_CORE     = \"0\" [bB] [0-1]+\n  HEX_CORE     = \"0\" [xX] [0-9a-fA-F]+\n  ZERO         = \"0\"\nlexical syntax\n  ID           = \"nan\" {reject}\n  ID           = \"inf\" {reject}\nlexical restrictions\n  REAL         -/- [fF]\n  REAL_CORE_NE -/- [eE]\n  INT_CORE_NE  -/- [eE]\n  HEX_CORE     -/- [0-9a-fA-F]\n  ZERO         -/- [xX]\n  ZERO         -/- [bB]\n\n\n// --- STRINGS -------\n\nlexical sorts\n  STRING CHARACTER\n  STRING_CHAR CHARACTER_CHAR\n  ESCAPE_SEQUENCE ESCAPE_ZERO BACKSLASH_CHAR\nlexical syntax\n  STRING          = \"\\\"\" STRING_CHAR* \"\\\"\"\n  CHARACTER       = \"'\" CHARACTER_CHAR \"'\"\n\n  STRING_CHAR     = ~[\\\\\\\"\\n]\n  STRING_CHAR     = ESCAPE_SEQUENCE\n\n  CHARACTER_CHAR  = ~[\\\\\\'\\n]\n  CHARACTER_CHAR  = ESCAPE_SEQUENCE\n  CHARACTER_CHAR  = ESCAPE_ZERO\n\n  ESCAPE_SEQUENCE = \"\\\\\" [ntvbrfa\\\\\\?\\'\\\"]\n  ESCAPE_SEQUENCE = \"\\\\x\" [0-9a-fA-F][0-9a-fA-F]?\n  ESCAPE_SEQUENCE = \"\\\\x0\" {reject}\n  ESCAPE_SEQUENCE = \"\\\\x00\" {reject}\n  ESCAPE_ZERO     = \"\\\\x0\" | \"\\\\x00\"\n\n\n// --- LAYOUT -------\n\nlexical sorts\n  ML_COM\n  LONESTAR\n  EOF\nlexical syntax\n  LAYOUT   = [\\ \\t\\n\\r]\n  LAYOUT   = ML_COM\n  ML_COM   = \"/*\"\n               (~[\\*] | LONESTAR | ML_COM)*\n             \"*/\"\n  LAYOUT   = \"//\" ~[\\n\\r]* ([\\n\\r] | EOF)\n  LONESTAR = [\\*]\n  EOF      =\nlexical restrictions\n  LONESTAR -/- [\\/] \n  EOF      -/- ~[]\ncontext-free restrictions\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\/]\n  LAYOUT? -/- [\\/].[\\*]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/syntax/Common.sdf3/#modal-h2","title":"Common.sdf3","text":""},{"location":"org.metaborg.lang.poosl/syntax/ExprStat.sdf3/","title":"<code>ExprStat.sdf3</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/syntax/ExprStat.sdf3</p> <pre><code>module ExprStat\n\nimports\n    Common\n\ncontext-free sorts\n    Statement\n    SingleStatement\n    AndStatement\n    OrStatement\n    ProcessMethodCall\n    CaseStatementList\n    CaseStatement\n    OptDefaultStatement\n\n    Expression\n    SingleExpression\n    OnSuperClass\n    OptExpressionList\n    OptVariableList\n    ExpressionList\n    CaseExpressionList\n    CaseExpression\n    OptDefaultExpression\n    ExpressionConstant\n    UnaryOperator\n    BinaryOperatorLevel2\n    BinaryOperatorLevel3\n    BinaryOperatorLevel4\n    VariableList\n    OptPostExpression\n    OptReceptionCondition\n\ncontext-free syntax\n\n    // === Statements =======\n\n    Statement.StatementSequence =                   [[{SingleStatement \";\\n\"}+]]\n\n    SingleStatement.AbortStatement = [\n        abort\n            [Statement]\n        with\n            [SingleStatement]\n        ]\n    SingleStatement.DelayStatement =                [delay [SingleExpression]]\n    SingleStatement.GuardedStatement =              &lt;[&lt;Expression&gt;] &lt;SingleStatement&gt;&gt;\n    SingleStatement.InterruptStatement = [\n        interrupt\n            [Statement]\n        with\n            [SingleStatement]\n        ]\n    SingleStatement.ParStatement = [\n        par\n            [Statement]\n        [AndStatement+]\n        rap\n        ]\n    SingleStatement.ProcessMethodCallStatement =    ProcessMethodCall\n    SingleStatement.SelStatement = [\n        sel\n            [Statement]\n        [OrStatement+]\n        les\n        ]\n    SingleStatement.SkipStatement =                 [skip]\n    SingleStatement.SendStatement =                 [[ID]![ID][OptExpressionList] [OptPostExpression]]\n    SingleStatement.ReceiveStatement =              [[ID]?[ID][OptVariableList] [OptReceptionCondition] [OptPostExpression]]\n    SingleStatement.IfThenStatement = [\n        if [Expression] then \n            [Statement]\n        fi\n        ]\n    SingleStatement.IfThenElseStatement = [\n        if [Expression] then\n            [Statement]\n        else\n            [Statement]\n        fi\n        ]\n    SingleStatement.RoundBracketStatement = [\n        (\n            [Statement]\n        )\n        ]\n    SingleStatement.WhileStatement = [\n        while [Expression] do\n            [Statement]\n        od\n        ]\n    SingleStatement.SwitchStatement = [\n        switch [Expression] do\n            [CaseStatementList]\n            [OptDefaultStatement]\n        od\n        ]\n    SingleStatement.ExpressionStatement =           SingleExpression\n    SingleStatement.CurlyExpressionStatement =      [{ [Expression] }]\n\n    ProcessMethodCall.ProcessMethodCall =           [[ID][ExpressionList][VariableList]]\n\n    AndStatement.AndStatement = [\n        and\n            [Statement]\n    ]\n    OrStatement.OrStatement = [\n        or\n            [Statement]\n    ]\n\n    CaseStatementList.CaseStatementList =           [[{CaseStatement \"\\n\"}*]]\n    CaseStatement.CaseStatement =\n        [case [Expression] then\n            [Statement]]\n    OptDefaultStatement.DefaultStatement =\n        [default\n            [Statement]]\n    OptDefaultStatement.NoDefaultStatement =        []\n\n    OptPostExpression.PostExpression =              [{ [Expression] }]\n    OptPostExpression.NoPostExpression =            []\n\n    OptReceptionCondition.ReceptionCondition =      [| [Expression] |]\n    OptReceptionCondition.NoReceptionCondition =    []\n\n    OptVariableList.Variables =                     [([{ID \", \"}*])]\n    OptVariableList.NoVariables =                   []\n\n    VariableList.VariableList =                     [([{ID \", \"}*])]\n\n\n    // === Expressions =======\n\n    Expression.ExpressionSequence =                 [[{SingleExpression \";\\n\"}+]]\n\n    // --- Level 1 -------\n    SingleExpression.AssignmentExpression =         [[ID] := [SingleExpression]]\n    SingleExpression.ReturnExpression =             [return [SingleExpression]]\n    // --- Level 2-4  -------   \n    SingleExpression.BinaryOperatorExpression2 =    [[SingleExpression] [BinaryOperatorLevel2] [SingleExpression]]  {left}\n    SingleExpression.BinaryOperatorExpression3 =    [[SingleExpression] [BinaryOperatorLevel3] [SingleExpression]]  {left}\n    SingleExpression.BinaryOperatorExpression4 =    [[SingleExpression] [BinaryOperatorLevel4] [SingleExpression]]  {left}\n    // --- Level 5 -------\n    SingleExpression.DataMethodCallExpression =     [[SingleExpression][OnSuperClass] [ID][OptExpressionList]]\n    // --- Level 6 -------\n    SingleExpression.UnaryOperatorExpression =      [[UnaryOperator][SingleExpression]]\n    SingleExpression.IfThenExpression = [\n        if [Expression] then\n            [Expression]\n        fi\n        ]\n    SingleExpression.IfThenElseExpression = [\n        if [Expression] then\n            [Expression]\n        else\n            [Expression]\n        fi\n        ]\n    SingleExpression.WhileExpression = [\n        while [Expression] do\n            [Expression]\n        od\n        ]\n    SingleExpression.SwitchExpression = [\n        switch [Expression] do\n            [CaseExpressionList]\n            [OptDefaultExpression]\n        od\n        ]\n    // --- Level 7 -------\n    SingleExpression.CurrentTimeExpression =        [currentTime]\n    SingleExpression.SelfExpression =               [self]\n    SingleExpression.ConstantExpression =           ExpressionConstant\n    SingleExpression.NewExpression =                [new ([ID])]\n    SingleExpression.VariableExpression =           ID\n    SingleExpression.RoundBracketExpression =       [([Expression])]\n\n    ExpressionConstant.BooleanConstant =            BOOL\n    ExpressionConstant.CharacterConstant =          CHARACTER\n    ExpressionConstant.FloatConstant =              FLOAT\n    ExpressionConstant.IntegerConstant =            INT\n    ExpressionConstant.NilConstant =                [nil]\n    ExpressionConstant.RealConstant =               REAL\n    ExpressionConstant.StringConstant =             STRING\n    ExpressionConstant.EnvironmentConstant =        ENV\n\n    OnSuperClass.OnSuperClass =                     [^]\n    OnSuperClass.NotOnSuperClass =                  []\n\n    OptExpressionList.Expressions =                 [([{Expression \", \"}*])]\n    OptExpressionList.NoExpressions =               []\n\n    ExpressionList.ExpressionList =                 [([{Expression \", \"}*])]\n\n    CaseExpressionList.CaseExpressionList =         [[{CaseExpression \"\\n\"}*]]\n    CaseExpression.CaseExpression =\n        [case [Expression] then\n            [Expression]]\n    OptDefaultExpression.DefaultExpression =\n        [default\n            [Expression]]\n    OptDefaultExpression.NoDefaultExpression =      []\n\n    // --- Operators -------\n    UnaryOperator.Minus =                           [-]\n    UnaryOperator.Not =                             [!]\n\n    BinaryOperatorLevel2.Equal =                    [=]\n    BinaryOperatorLevel2.Unequal =                  [!=]\n    BinaryOperatorLevel2.Identical =                [==]\n    BinaryOperatorLevel2.NotIdentical =             [!==]\n    BinaryOperatorLevel2.LessThan =                 [&lt;]\n    BinaryOperatorLevel2.AtMost =                   [&lt;=]\n    BinaryOperatorLevel2.GreaterThan =              [&gt;]\n    BinaryOperatorLevel2.AtLeast =                  [&gt;=]\n\n    BinaryOperatorLevel3.Add =                      [+]\n    BinaryOperatorLevel3.Subtract =                 [-]\n    BinaryOperatorLevel3.And =                      [&amp;]\n    BinaryOperatorLevel3.Or =                       [|]\n\n    BinaryOperatorLevel4.Multiply =                 [*]\n    BinaryOperatorLevel4.Divide =                   [/]\n\ncontext-free restrictions\n    UnaryOperator -/- [0-9]                         // Parse -42 as Integer instead of UnaryOperation (but 42-0 should be allowed)\n\ncontext-free priorities\n    // If A &gt; B, then all trees are removed that have a B node as a direct child of an A node.\n    SingleStatement.ExpressionStatement &lt;0&gt; &gt;\n        { SingleExpression.RoundBracketExpression\n          SingleExpression.IfThenExpression\n          SingleExpression.IfThenElseExpression\n          SingleExpression.WhileExpression\n          SingleExpression.SwitchExpression},\n\n    SingleExpression.UnaryOperatorExpression &gt;\n        SingleExpression.DataMethodCallExpression &gt;\n        SingleExpression.BinaryOperatorExpression4 &gt;\n        SingleExpression.BinaryOperatorExpression3 &gt;\n        SingleExpression.BinaryOperatorExpression2 &gt;\n        { SingleExpression.AssignmentExpression SingleExpression.ReturnExpression }\n\nlexical syntax      // keywords\n    ID = \"if\"           {reject}\n    ID = \"then\"         {reject}\n    ID = \"else\"         {reject}\n    ID = \"fi\"           {reject}\n\n    ID = \"while\"        {reject}\n    ID = \"do\"           {reject}\n    ID = \"od\"           {reject}\n\n    ID = \"switch\"       {reject}\n    ID = \"case\"         {reject}\n    ID = \"default\"      {reject}\n\n    ID = \"par\"          {reject}\n    ID = \"and\"          {reject}\n    ID = \"rap\"          {reject}\n\n    ID = \"sel\"          {reject}\n    ID = \"or\"           {reject}\n    ID = \"les\"          {reject}\n\n    ID = \"abort\"        {reject}\n    ID = \"interrupt\"    {reject}\n    ID = \"with\"         {reject}\n\n    ID = \"delay\"        {reject}\n    ID = \"skip\"         {reject}\n\n    ID = \"currentTime\"  {reject}\n    ID = \"new\"          {reject}\n    ID = \"nil\"          {reject}\n    ID = \"self\"         {reject}\n    ID = \"return\"       {reject}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/syntax/ExprStat.sdf3/#modal-h2","title":"ExprStat.sdf3","text":""},{"location":"org.metaborg.lang.poosl/syntax/Poosl.sdf3/","title":"<code>Poosl.sdf3</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/syntax/Poosl.sdf3</p> <pre><code>module Poosl\n\nimports\n    Common\n    ExprStat\n\ncontext-free start-symbols\n    Poosl\n\ncontext-free sorts\n    Poosl\n    ImportList\n    Import\n    AnnotationList\n    Annotation\n    OptAnnotationArgs\n    Class\n    ClassList\n    DataMethodList\n    DataMethod\n    OperatorBinary\n    NativeClause\n    ExtendsClause\n    IDList\n    Declaration\n    DeclarationOptCommaList\n    DeclarationOptComma\n    ParameterList\n    OptEmptyList\n    OptParameterList\n    OptLocalVariableList\n    ProcessMethodList\n    ProcessMethod\n    PortList\n    Port\n    MessageSignatureList\n    MessageSignature\n    OptMessageParameterList\n    InstanceList\n    Instance\n    OptInstanceParameterList\n    InstanceParameter\n    ChannelList\n    Channel\n    PortInstance\n    PortInstanceList\n    OptionalComma\n\ncontext-free syntax\n    Poosl.Poosl = [\n        [ImportList]\n        [ClassList]\n    ]\n\n    ImportList.ImportList =                             [[{Import \"\\n\"}*]]\n    ClassList.ClassList =                               [[{Class \"\\n\\n\"}*]]\n\n    // === Multiple files =======\n\n    Import.Import =                                     [import [STRING]]\n    Import.ImportLib =                                  [importlib [STRING]]\n\n    // === Annotation =======\n\n    AnnotationList.AnnotationList =                     Annotation*\n    Annotation.Annotation =                             [@[ID][OptAnnotationArgs]]\n    OptAnnotationArgs.AnnotationArgs =                  [([{ExpressionConstant \", \"}*])]\n    OptAnnotationArgs.NoAnnotationArgs =                []\n\n    // === Data Class =======\n\n    Class.DataClass = [\n        [AnnotationList]\n        [NativeClause] data class [ID] [ExtendsClause]\n        variables\n            [DeclarationOptCommaList]\n        methods\n            [DataMethodList]\n    ]\n\n    DataMethodList.DataMethodList =                     [[{DataMethod \"\\n\\n\"}*]]\n    DataMethod.DataMethodNamed = [\n        [AnnotationList]\n        [ID][OptParameterList] : [ID] [OptLocalVariableList]\n            [Expression]\n    ]\n    DataMethod.DataMethodUnary = [\n        [AnnotationList]\n        [UnaryOperator][OptEmptyList] : [ID] [OptLocalVariableList]\n            [Expression]\n    ]\n    DataMethod.DataMethodBinary = [\n        [AnnotationList]\n        [OperatorBinary]([Declaration]) : [ID] [OptLocalVariableList]\n            [Expression]\n    ]\n    DataMethod.DataMethodNamedNative = [\n        native [ID][OptParameterList] : [ID]\n    ]\n    DataMethod.DataMethodUnaryNative = [\n        native [UnaryOperator][OptEmptyList] : [ID]\n    ]\n    DataMethod.DataMethodBinaryNative = [\n        native [OperatorBinary]([Declaration]) : [ID]\n    ]\n\n    OptEmptyList.NoList = []\n    OptEmptyList.EmptyList = [()]\n\n    OperatorBinary.OperatorBinary2 =                    BinaryOperatorLevel2\n    OperatorBinary.OperatorBinary3 =                    BinaryOperatorLevel3\n    OperatorBinary.OperatorBinary4 =                    BinaryOperatorLevel4\n\n    NativeClause.Native =                               [native]\n    NativeClause.NotNative =                            []\n\n    ExtendsClause.Extends =                             [extends [ID]]\n    ExtendsClause.NoExtends =                           []\n\n    IDList.IDList =                                     [[{ID \", \"}*]]\n    Declaration.Declaration =                           [[IDList] : [ID]]\n    DeclarationOptComma.DeclarationWithComma =          [[IDList] : [ID],]\n    DeclarationOptComma.DeclarationWithoutComma =       [[IDList] : [ID]]\n\n    DeclarationOptCommaList.DeclarationOptCommaList =   [[{DeclarationOptComma \"\\n\"}*]] \n    ParameterList.ParameterList =                       [([{Declaration \", \"}*])]\n    OptParameterList.Parameters =                       [([{Declaration \", \"}*])]\n    OptParameterList.NoParameters =                     []\n    OptLocalVariableList.LocalVariables =               [| [{Declaration \", \"}*] |]\n    OptLocalVariableList.NoLocalVariables =             []\n\n    // === Process Class =======\n\n    Class.ProcessClass = [\n        [AnnotationList]\n        process class [ID][OptParameterList] [ExtendsClause]\n        ports\n            [PortList]\n        messages\n            [MessageSignatureList]\n        variables\n            [DeclarationOptCommaList]\n        init\n            [ProcessMethodCall]\n        methods\n            [ProcessMethodList]\n    ]\n\n    ProcessMethodList.ProcessMethodList =               [[{ProcessMethod \"\\n\\n\"}*]]\n    ProcessMethod.ProcessMethod = [\n        [AnnotationList]\n        [ID][ParameterList][ParameterList] [OptLocalVariableList]\n            [Statement]\n    ]\n\n    PortList.PortList =                                 [[{Port \"\\n\"}*]]\n    Port.Port =                                         [[ID][OptionalComma]]\n\n    MessageSignatureList.MessageSignatureList =         [[{MessageSignature \"\\n\"}*]]\n    MessageSignature.MessageReceiveSignature =          [[ID]?[ID][OptMessageParameterList][OptionalComma]] \n    MessageSignature.MessageSendSignature =             [[ID]![ID][OptMessageParameterList][OptionalComma]]\n\n    OptMessageParameterList.MessageParameters =         [([{ID \", \"}*])]\n    OptMessageParameterList.NoMessageParameters =       []\n\n\n    // === System and Cluster Class =======\n\n    Class.System =  [\n        [AnnotationList]\n        system\n        instances\n            [InstanceList]\n        channels\n            [ChannelList]\n    ]\n\n    Class.ClusterClass = [\n        [AnnotationList]\n        cluster class [ID][OptParameterList]\n        ports\n            [PortList]\n        instances\n            [InstanceList]\n        channels\n            [ChannelList]\n    ]\n\n    InstanceList.InstanceList =                         [[{Instance \"\\n\"}*]]\n    Instance.Instance = [\n        [AnnotationList]\n        [ID] : [ID][OptInstanceParameterList]\n    ]\n\n    OptInstanceParameterList.InstanceParameters =       [([{InstanceParameter \", \"}*])]\n    OptInstanceParameterList.NoInstanceParameters =     []\n\n    InstanceParameter.InstanceParameter =               [[ID] := [Expression]]\n\n    ChannelList.ChannelList =                           [[{Channel \"\\n\"}*]]\n    Channel.Channel = [\n        [AnnotationList]\n        { [PortInstanceList] }\n    ]\n\n    PortInstanceList.PortInstanceList =                 [[{PortInstance \", \"}+]]\n    PortInstance.InternalPort =                         [[ID].[ID]]\n    PortInstance.ExternalPort =                         ID\n\n    // === Workarounds =======\n\n    OptionalComma.Comma =                               [,]\n    OptionalComma.NoComma =                             []\n\nlexical syntax      // keywords\n    ID = \"import\"       {reject}\n    ID = \"importlib\"    {reject}\n\n    ID = \"data\"         {reject}\n    ID = \"process\"      {reject}\n    ID = \"cluster\"      {reject}\n    ID = \"system\"       {reject}\n\n    ID = \"native\"       {reject}\n\n// Note: No reserved words!\n//  ID = \"class\"        {reject}\n//  ID = \"extends\"      {reject}\n//  ID = \"variables\"    {reject}\n//  ID = \"methods\"      {reject}\n//  ID = \"ports\"        {reject}\n//  ID = \"messages\"     {reject}\n//  ID = \"init\"         {reject}\n//  ID = \"channels\"     {reject}\n//  ID = \"instances\"    {reject}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/syntax/Poosl.sdf3/#modal-h2","title":"Poosl.sdf3","text":""},{"location":"org.metaborg.lang.poosl/syntax/Stratego-Poosl.sdf3/","title":"<code>Stratego-Poosl.sdf3</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/syntax/Stratego-Poosl.sdf3</p> <pre><code>module Stratego-Poosl\n\nimports\n\n    // Meta language\n    StrategoLang/import-namespaced\n    StrategoLang/sugar/terms-namespaced\n    StrategoLang/core/modules-namespaced\n\n    // Object Language\n    Poosl\n    ExprStat\n\ncontext-free start-symbols\n\n    Start   // Auxiliary start symbol is a workaround to avoid pretty-print error\n\ncontext-free syntax     // === Auxiliary start symbol =======\n\n    Start = StrategoLang-Module // from StrategoLang/import-namespaced\n\ncontext-free syntax     // === Quotation =======\n\n    // --- Poosl.sdf3 -------\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Poosl \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"poosl\"            \"|[\" Poosl \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Import \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"import\"           \"|[\" Import \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Annotation \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"annotation\"       \"|[\" Annotation \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Class \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"class\"            \"|[\" Class \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" DataMethod \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"dataMethod\"       \"|[\" DataMethod \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" ProcessMethod \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"processMethod\"    \"|[\" ProcessMethod \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Port \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"port\"             \"|[\" Port \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" MessageSignature \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"messageSignature\" \"|[\" MessageSignature \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Instance \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"instance\"         \"|[\" Instance \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Channel \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"channel\"          \"|[\" Channel \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" PortInstance \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"portInstance\"     \"|[\" PortInstance \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Declaration \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"declaration\"      \"|[\" Declaration \"]|\"\n\n    // --- ExprStat.sdf3 -------\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Statement \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"statements\"       \"|[\" Statement \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" SingleStatement \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"statement\"        \"|[\" SingleStatement \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" CaseStatement \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"caseStatement\"    \"|[\" CaseStatement \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" Expression \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"expressions\"      \"|[\" Expression \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" SingleExpression \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"expression\"       \"|[\" SingleExpression \"]|\"\n    StrategoLang-PreTerm.ToTerm =                    \"|[\" CaseExpression \"]|\"\n    StrategoLang-PreTerm.ToTerm = \"caseExpression\"   \"|[\" CaseExpression \"]|\"\n\ncontext-free syntax     // === Anti-quotation =======\n\n    // --- Poosl.sdf3 -------\n    Poosl                   .FromTerm = \"~\"                     StrategoLang-Term\n    Poosl                   .FromTerm = \"~poosl:\"               StrategoLang-Term\n\n    Import                  .FromTerm = \"~\"                     StrategoLang-Term\n    Import                  .FromTerm = \"~import:\"              StrategoLang-Term\n    ImportList              .FromTerm = \"~*\"                    StrategoLang-Term\n    ImportList              .FromTerm = \"~*imports:\"            StrategoLang-Term\n\n    Annotation              .FromTerm = \"~\"                     StrategoLang-Term\n    Annotation              .FromTerm = \"~annotation:\"          StrategoLang-Term\n    AnnotationList          .FromTerm = \"~*\"                    StrategoLang-Term\n    AnnotationList          .FromTerm = \"~*annotations:\"        StrategoLang-Term\n\n    Class                   .FromTerm = \"~\"                     StrategoLang-Term\n    Class                   .FromTerm = \"~class:\"               StrategoLang-Term\n    ClassList               .FromTerm = \"~*\"                    StrategoLang-Term\n    ClassList               .FromTerm = \"~*classes:\"            StrategoLang-Term\n\n    ExtendsClause           .FromTerm = \"~\"                     StrategoLang-Term\n    ExtendsClause           .FromTerm = \"~extends:\"             StrategoLang-Term\n\n    DataMethod              .FromTerm = \"~\"                     StrategoLang-Term\n    DataMethod              .FromTerm = \"~method:\"              StrategoLang-Term\n    DataMethodList          .FromTerm = \"~\"                     StrategoLang-Term\n    DataMethodList          .FromTerm = \"~*methods:\"            StrategoLang-Term\n    ProcessMethod           .FromTerm = \"~\"                     StrategoLang-Term\n    ProcessMethod           .FromTerm = \"~method:\"              StrategoLang-Term\n    ProcessMethodList       .FromTerm = \"~\"                     StrategoLang-Term\n    ProcessMethodList       .FromTerm = \"~*methods:\"            StrategoLang-Term\n\n    ID                      .FromTerm = \"~\"                     StrategoLang-Term\n    ID                      .FromTerm = \"~id:\"                  StrategoLang-Term\n    IDList                  .FromTerm = \"~*\"                    StrategoLang-Term\n    IDList                  .FromTerm = \"~*ids:\"                StrategoLang-Term\n    OptMessageParameterList .FromTerm = \"~*\"                    StrategoLang-Term\n    OptMessageParameterList .FromTerm = \"~*ids:\"                StrategoLang-Term\n    OptVariableList         .FromTerm = \"~*\"                    StrategoLang-Term\n    OptVariableList         .FromTerm = \"~*ids:\"                StrategoLang-Term\n    VariableList            .FromTerm = \"~*\"                    StrategoLang-Term\n    VariableList            .FromTerm = \"~*ids:\"                StrategoLang-Term\n    UnaryOperator           .FromTerm = \"~\"                     StrategoLang-Term\n    UnaryOperator           .FromTerm = \"~unOp:\"                StrategoLang-Term\n    OperatorBinary          .FromTerm = \"~\"                     StrategoLang-Term\n    OperatorBinary          .FromTerm = \"~binOp:\"               StrategoLang-Term\n\n    Declaration             .FromTerm = \"~\"                     StrategoLang-Term\n    Declaration             .FromTerm = \"~declaration:\"         StrategoLang-Term\n    DeclarationOptComma     .FromTerm = \"~\"                     StrategoLang-Term\n    DeclarationOptComma     .FromTerm = \"~declaration:\"         StrategoLang-Term\n    DeclarationOptCommaList .FromTerm = \"~*\"                    StrategoLang-Term\n    DeclarationOptCommaList .FromTerm = \"~*declarations:\"       StrategoLang-Term\n    ParameterList           .FromTerm = \"~*\"                    StrategoLang-Term\n    ParameterList           .FromTerm = \"~*declarations:\"       StrategoLang-Term\n    OptParameterList        .FromTerm = \"~*\"                    StrategoLang-Term\n    OptParameterList        .FromTerm = \"~*declarations:\"       StrategoLang-Term\n    OptLocalVariableList    .FromTerm = \"~*\"                    StrategoLang-Term\n    OptLocalVariableList    .FromTerm = \"~*declarations:\"       StrategoLang-Term\n    OptEmptyList            .FromTerm = \"~*\"                    StrategoLang-Term\n    OptEmptyList            .FromTerm = \"~*declarations:\"       StrategoLang-Term\n\n    Port                    .FromTerm = \"~\"                     StrategoLang-Term\n    Port                    .FromTerm = \"~port:\"                StrategoLang-Term\n    PortList                .FromTerm = \"~*\"                    StrategoLang-Term\n    PortList                .FromTerm = \"~*ports:\"              StrategoLang-Term\n\n    MessageSignature        .FromTerm = \"~\"                     StrategoLang-Term\n    MessageSignature        .FromTerm = \"~message:\"             StrategoLang-Term\n    MessageSignatureList    .FromTerm = \"~*\"                    StrategoLang-Term\n    MessageSignatureList    .FromTerm = \"~*messages:\"           StrategoLang-Term\n\n    Instance                .FromTerm = \"~\"                     StrategoLang-Term\n    Instance                .FromTerm = \"~instance:\"            StrategoLang-Term\n    InstanceList            .FromTerm = \"~*\"                    StrategoLang-Term\n    InstanceList            .FromTerm = \"~*instances:\"          StrategoLang-Term\n\n    Channel                 .FromTerm = \"~\"                     StrategoLang-Term\n    Channel                 .FromTerm = \"~channel:\"             StrategoLang-Term\n    ChannelList             .FromTerm = \"~*\"                    StrategoLang-Term\n    ChannelList             .FromTerm = \"~*channels:\"           StrategoLang-Term\n\n    InstanceParameter       .FromTerm = \"~\"                     StrategoLang-Term\n    InstanceParameter       .FromTerm = \"~instanceParameter:\"   StrategoLang-Term\n    OptInstanceParameterList.FromTerm = \"~*\"                    StrategoLang-Term\n    OptInstanceParameterList.FromTerm = \"~*instanceParameters:\" StrategoLang-Term\n    PortInstance            .FromTerm = \"~\"                     StrategoLang-Term\n    PortInstance            .FromTerm = \"~portInstance:\"        StrategoLang-Term\n\n    // --- ExprStat.sdf3 -------\n    Statement               .FromTerm = \"~*\"                    StrategoLang-Term\n    Statement               .FromTerm = \"~*statements:\"         StrategoLang-Term\n    SingleStatement         .FromTerm = \"~\"                     StrategoLang-Term\n    SingleStatement         .FromTerm = \"~statement:\"           StrategoLang-Term\n    CaseStatement           .FromTerm = \"~\"                     StrategoLang-Term\n    CaseStatement           .FromTerm = \"~caseStatement:\"       StrategoLang-Term\n    CaseStatementList       .FromTerm = \"~*\"                    StrategoLang-Term\n    CaseStatementList       .FromTerm = \"~*caseStatements:\"     StrategoLang-Term\n    Expression              .FromTerm = \"~*\"                    StrategoLang-Term\n    Expression              .FromTerm = \"~*expressions:\"        StrategoLang-Term\n    SingleExpression        .FromTerm = \"~\"                     StrategoLang-Term\n    SingleExpression        .FromTerm = \"~expression:\"          StrategoLang-Term\n    CaseExpression          .FromTerm = \"~\"                     StrategoLang-Term\n    CaseExpression          .FromTerm = \"~caseExpression:\"      StrategoLang-Term\n    CaseExpressionList      .FromTerm = \"~*\"                    StrategoLang-Term\n    CaseExpressionList      .FromTerm = \"~*caseExpressions:\"    StrategoLang-Term\n\n    // --- Common.sdf3 -------\n    BOOL                    .FromTerm = \"~boolean:\"             StrategoLang-Term\n    CHARACTER               .FromTerm = \"~char:\"                StrategoLang-Term\n    FLOAT                   .FromTerm = \"~float:\"               StrategoLang-Term\n    INT                     .FromTerm = \"~int:\"                 StrategoLang-Term\n    REAL                    .FromTerm = \"~real:\"                StrategoLang-Term\n    STRING                  .FromTerm = \"~string:\"              StrategoLang-Term\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/syntax/Stratego-Poosl.sdf3/#modal-h2","title":"Stratego-Poosl.sdf3","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-bool.stx/","title":"<code>statics-bool.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-bool.stx</p> <pre><code>module statics-bool\n\nsignature\n\n    sorts\n        TYPE_BOOL\n\n    constructors\n        FALSE : TYPE_BOOL\n        TRUE : TYPE_BOOL\n\nrules\n\n    forall : list(TYPE_BOOL) -&gt; TYPE_BOOL\n    forall([]          ) = TRUE().\n    forall([FALSE()|Ts]) = FALSE().\n    forall([TRUE() |Ts]) = forall(Ts).\n\n    bool_and : TYPE_BOOL * TYPE_BOOL -&gt; TYPE_BOOL\n    bool_and(FALSE(), _      ) = FALSE().\n    bool_and(TRUE() , x      ) = x.\n//  bool_and(_      , FALSE()) = FALSE().\n//  bool_and(x      , TRUE() ) = x.\n\n    or : TYPE_BOOL * TYPE_BOOL -&gt; TYPE_BOOL\n    or(FALSE(), x      ) = x.\n    or(TRUE() , _      ) = TRUE().\n//  or(x      , FALSE()) = x.\n//  or(_      , TRUE() ) = TRUE().\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-bool.stx/#modal-h2","title":"statics-bool.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-comm.stx/","title":"<code>statics-comm.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-comm.stx</p> <pre><code>module statics-comm\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n    statics-opt\n    statics-names\n    statics-expr-stat\n    statics-typing\n\nrules // === Ports and messages =======\n\n    okPorts maps okPort(*, list(*))\n    okPort : scope * Port\n    okPort(s, Port(name, _)) :- declarePort(s, name).\n\n    okMessageSignatures maps okMessageSignature(*, list(*))\n    okMessageSignature : scope * MessageSignature\n    okMessageSignature(s, MessageReceiveSignature(port, message, parameters, _)) :-\n        typeOfPort(s, port),\n        {typesParameters} typesParameters == okOptMessageParameterList(s, parameters),\n        declareReceiveMessage(s, port, message, TypeMessage(typesParameters)).\n    okMessageSignature(s, MessageSendSignature(port, message, parameters, _)) :-\n        typeOfPort(s, port),\n        {typesParameters} typesParameters == okOptMessageParameterList(s, parameters),\n        declareSendMessage(s, port, message, TypeMessage(typesParameters)).\n\n    okOptMessageParameterList : scope * OptMessageParameterList -&gt; list(TypeDataClass)\n    okOptMessageParameterList(s, MessageParameters(types)) = typeOfDataClasses(s, types).\n    okOptMessageParameterList(s, NoMessageParameters()) = [].\n\nrules // === Instances and channels =======\n\n    okInstances maps okInstance(*, list(*))\n    okInstance : scope * Instance\n    okInstance(s, Instance(annotationList, name, class, optParameterInstantiations)) :-\n        {T} T == typeOfProcessOrClusterClass(s, class),\n        declareInstance(s, name, T),\n        okInstanceParameters(s, externalScopeOfTypeProcessOrClusterClass(T), stripOptInstanceParameterList(optParameterInstantiations)).\n\n    okInstanceParameters maps okInstanceParameter(*, *, list(*))\n    okInstanceParameter : scope * scope * InstanceParameter\n    okInstanceParameter(s, s_instance, InstanceParameter(name, expr)) :-\n        {T_var} T_var == typeOfVariable(s_instance, name),\n        {T_expr} T_expr == okExpression(s, TypeDataClassRoot(), expr),\n        try { compatibleType(T_var, T_expr) } | warning $[Incompatible type] @expr.\n\n    okChannels maps okChannel(*, list(*))\n    okChannel : scope * Channel\n    okChannel(s, Channel(annotationList, PortInstanceList(portInstances))) :-\n        {count_ext_ports} count_ext_ports == countExternalPorts(portInstances),\n        try { atMostOne(count_ext_ports) } | error $[There should be at most 1 external port],\n        okPortInstances(s, portInstances),\n        okChannelClosure(s, portInstances, count_ext_ports).\n\n    okChannelClosure : scope * list(PortInstance) * int\n    okChannelClosure(s, pis, 0).\n    okChannelClosure(s, pis, _).\n        // TODO check unconnected messages\n        // TODO check type compatibility of messages\n\n    okPortInstances maps okPortInstance(*, list(*))\n    okPortInstance : scope * PortInstance\n    okPortInstance(s, InternalPort(instanceName, portName)) :-\n        {T_instance} T_instance == typeOfInstance(s, instanceName),\n        {T_instance_scope} T_instance_scope ==  externalScopeOfTypeProcessOrClusterClass(T_instance),\n        typeOfPort(T_instance_scope, portName).\n    okPortInstance(s, ExternalPort(portName)) :-\n        typeOfPort(s, portName).\n\nrules\n\n    externalScopeOfTypeProcessOrClusterClass : TypeProcessOrClusterClass -&gt; scope\n    externalScopeOfTypeProcessOrClusterClass(TypeClusterClass(s_external)) = s_external.\n    externalScopeOfTypeProcessOrClusterClass(TypeProcessClass(s_external, s_internal)) = s_external.\n\nrules\n\n    countExternalPorts : list(PortInstance) -&gt; int\n    countExternalPorts([]) = 0.\n    countExternalPorts([ExternalPort(_)|Cs]) = len :- {t_len}\n        t_len == countExternalPorts(Cs),\n        len #= t_len + 1.\n    countExternalPorts([_|Cs]) = countExternalPorts(Cs).\n\n    atMostOne : int\n    atMostOne(0).\n    atMostOne(1).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-comm.stx/#modal-h2","title":"statics-comm.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-expr-stat.stx/","title":"<code>statics-expr-stat.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-expr-stat.stx</p> <pre><code>module statics-expr-stat\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n    statics-opt\n    statics-names\n    statics-typing\n\nrules // === Declarations =======\n\n    okDeclarationOptCommas maps okDeclarationOptComma(*, list(*))\n    okDeclarationOptComma : scope * DeclarationOptComma\n    okDeclarationOptComma(s, DeclarationWithComma(IDList(names), type)) :-    declareVariables(s, names, typeOfDataClass(s, type)).\n    okDeclarationOptComma(s, DeclarationWithoutComma(IDList(names), type)) :- declareVariables(s, names, typeOfDataClass(s, type)).\n\n    okDeclarations maps okDeclaration(*, list(*)) = list(*)\n    okDeclaration : scope * Declaration -&gt; list(TypeDataClass)\n    okDeclaration(s, Declaration(IDList(names), type)) = okVariablesWithTypes(s, names, typeOfDataClass(s, type)).\n\n    okVariablesWithTypes maps okVariableWithType(*, list(*), *) = list(*)\n    okVariableWithType : scope * string * TypeDataClass -&gt; TypeDataClass\n    okVariableWithType(s, n, T) = T :- declareVariable(s, n, T).\n\nrules // === Statements =======\n\n    okProcessMethodCall : scope * ProcessMethodCall\n    okProcessMethodCall(s, ProcessMethodCall(name, ExpressionList(exprs), VariableList(vars))) :-\n        {argInTypes} argInTypes == okExpressions(s, TypeDataClassRoot(), exprs),\n        {argOutTypes} argOutTypes == typeOfVariables(s, vars),\n        {methodInTypes methodOutTypes} TypeProcessMethod(methodInTypes, methodOutTypes) == typeOfProcessMethod(s, name, lengthDataClasses(argInTypes), lengthDataClasses(argOutTypes)),\n        try { compatibleTypes(argInTypes, methodInTypes) } | warning $[Incompatible type] @exprs,\n        try { compatibleTypes(argOutTypes, methodOutTypes) } | warning $[Incompatible type] @vars.\n\n    okStatements maps okStatement(*, list(*))\n    okStatement : scope * Statement\n    okStatement(s, StatementSequence(statements)) :-\n        okSingleStatements(s, statements).\n\n    okAndStatements maps okAndStatement(*, list(*))\n    okAndStatement : scope * AndStatement\n    okAndStatement(s, AndStatement(stat)) :- okStatement(s, stat).\n\n    okOrStatements maps okOrStatement(*, list(*))\n    okOrStatement : scope * OrStatement\n    okOrStatement(s, OrStatement(stat)) :- okStatement(s, stat).\n\n    okSingleStatements maps okSingleStatement(*, list(*))\n    okSingleStatement : scope * SingleStatement\n    okSingleStatement(s, AbortStatement(stat1, stat2)) :-\n        okStatement(s, stat1),\n        okSingleStatement(s, stat2).\n    okSingleStatement(s, DelayStatement(expr)) :-\n        okSingleExpression(s, TypeDataClassRoot(), expr) == _.\n    okSingleStatement(s, GuardedStatement(expr, stat)) :-\n        okExpression(s, TypeDataClassRoot(), expr) == _,\n        okSingleStatement(s, stat).\n    okSingleStatement(s, InterruptStatement(stat1, stat2)) :-\n        okStatement(s, stat1),\n        okSingleStatement(s, stat2).\n    okSingleStatement(s, ParStatement(stat, andStats)) :-\n        okStatement(s, stat),\n        okAndStatements(s, andStats).\n    okSingleStatement(s, ProcessMethodCallStatement(call)) :-\n        okProcessMethodCall(s, call).\n    okSingleStatement(s, SelStatement(stat, orStats)) :-\n        okStatement(s, stat),\n        okOrStatements(s, orStats).\n    okSingleStatement(s, SkipStatement()).\n    okSingleStatement(s, SendStatement(port, message, optExpressions, postExpression)) :-\n        typeOfPort(s, port),\n        {exprTypes} exprTypes == okExpressions(s, TypeDataClassRoot(), stripOptExpressionList(optExpressions)),\n        {msgTypes} TypeMessage(msgTypes) == typeOfSendMessage(s, port, message, lengthDataClasses(exprTypes)),\n        try { compatibleTypes(exprTypes, msgTypes) } | warning $[Incompatible type] @optExpressions,\n        okOptPostExpression(s, postExpression).\n    okSingleStatement(s, ReceiveStatement(port, message, optVariables, condition, postExpression)) :-\n        typeOfPort(s, port),\n        {varTypes} varTypes == typeOfVariables(s, stripOptVariableList(optVariables)),\n        {msgTypes} TypeMessage(msgTypes) == typeOfReceiveMessage(s, port, message, lengthDataClasses(varTypes)),\n        try { compatibleTypes(varTypes, msgTypes) } | warning $[Incompatible type] @optVariables,\n        okOptReceptionCondition(s, condition),\n        okOptPostExpression(s, postExpression).\n    okSingleStatement(s, IfThenStatement(condition, thenClause)) :-\n        {T_Condition} T_Condition == okExpression(s, TypeDataClassRoot(), condition),\n        okStatement(s, thenClause),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleStatement(s, IfThenElseStatement(condition, thenClause, elseClause)) :-\n        {T_Condition} T_Condition == okExpression(s, TypeDataClassRoot(), condition),\n        okStatement(s, thenClause),\n        okStatement(s, elseClause),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleStatement(s, RoundBracketStatement(stat)) :- okStatement(s, stat).\n    okSingleStatement(s, WhileStatement(condition, body)) :-\n        {T_Condition} T_Condition == okExpression(s, TypeDataClassRoot(), condition),\n        okStatement(s, body),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleStatement(s, SwitchStatement(expr, CaseStatementList(cases), default)) :-\n        try { nonEmptySwitchStatement(cases, default) } | error $[Missing case or default],\n        {T_Expr} T_Expr == okExpression(s, TypeDataClassRoot(), expr),\n        okOptDefaultStatement(s, default),\n        okCaseStatements(s, cases, T_Expr).\n    okSingleStatement(s, ExpressionStatement(expr)) :-\n        okSingleExpression(s, TypeDataClassRoot(), expr) == _.\n    okSingleStatement(s, CurlyExpressionStatement(expr)) :-\n        okExpression(s, TypeDataClassRoot(), expr) == _.\n\n    okOptReceptionCondition : scope * OptReceptionCondition\n    okOptReceptionCondition(s, ReceptionCondition(expr)) :- okExpression(s, TypeDataClassRoot(), expr) == _.\n    okOptReceptionCondition(s, NoReceptionCondition()).\n\n    okOptPostExpression : scope * OptPostExpression\n    okOptPostExpression(s, PostExpression(expr)) :- okExpression(s, TypeDataClassRoot(), expr) == _.\n    okOptPostExpression(s, NoPostExpression()).\n\n    okOptDefaultStatement : scope * OptDefaultStatement\n    okOptDefaultStatement(s, DefaultStatement(expr)) :- okStatement(s, expr).\n    okOptDefaultStatement(s, NoDefaultStatement()).\n\n    okCaseStatements maps okCaseStatement(*, list(*), *)\n    okCaseStatement : scope * CaseStatement * TypeDataClass\n    okCaseStatement(s, CaseStatement(condition, body), T_Expr) :-\n        {T_Condition} T_Condition == okExpression(s, TypeDataClassRoot(), condition),\n        okStatement(s, body),\n        try { compatibleType(T_Condition, T_Expr) } | warning $[Incompatible type] @condition.\n\nrules // === Expressions =======\n\n    okExpressions maps okExpression(*, *, list(*)) = list(*)\n    okExpression : scope * TypeDataClass * Expression -&gt; TypeDataClass\n    okExpression(s, typeClass, ExpressionSequence(exprs)) = okSingleExpressions(s, typeClass, exprs).\n\n    okSingleExpressions : scope * TypeDataClass * list(SingleExpression) -&gt; TypeDataClass\n    okSingleExpressions(s, typeClass, [expr]) =       okSingleExpression(s, typeClass, expr).\n    okSingleExpressions(s, typeClass, [expr|exprs]) = okSingleExpressions(s, typeClass, exprs) :-\n        okSingleExpression(s, typeClass, expr) == _.\n\n    okSingleExpression : scope * TypeDataClass * SingleExpression -&gt; TypeDataClass\n    okSingleExpression(s, typeClass, AssignmentExpression(var, expr)) = T :-\n        {T_Var} T_Var == typeOfVariable(s, var),\n        T == okSingleExpression(s, typeClass, expr),\n        try { compatibleType(T_Var, T) } | warning $[Incompatible type] @expr.\n    okSingleExpression(s, typeClass, ReturnExpression(expr)) =          okSingleExpression(s, typeClass, expr).\n    okSingleExpression(s, typeClass, BinaryOperatorExpression2(left, op, right)) = T :-\n        {T_Left} T_Left == okSingleExpression(s, typeClass, left),\n        {T_Right} T_Right == okSingleExpression(s, typeClass, right),\n        {T_Candidates} T_Candidates == typeOfBinaryDataMethods(s, OperatorBinary2(op)),\n        {T_Filtered_Candidates} T_Filtered_Candidates == filterCompatible(T_Candidates, T_Left, [T_Right]),\n        try { T_Filtered_Candidates == [_|_] } | warning $[No method with compatible parameter types],\n        T == gcaList(getDataMethodReturnTypes(T_Filtered_Candidates)).\n    okSingleExpression(s, typeClass, BinaryOperatorExpression3(left, op, right)) = T :-\n        {T_Left} T_Left == okSingleExpression(s, typeClass, left),\n        {T_Right} T_Right == okSingleExpression(s, typeClass, right),\n        {T_Candidates} T_Candidates == typeOfBinaryDataMethods(s, OperatorBinary3(op)),\n        {T_Filtered_Candidates} T_Filtered_Candidates == filterCompatible(T_Candidates, T_Left, [T_Right]),\n        try { T_Filtered_Candidates == [_|_] } | warning $[No method with compatible parameter types],\n        T == gcaList(getDataMethodReturnTypes(T_Filtered_Candidates)).\n    okSingleExpression(s, typeClass, BinaryOperatorExpression4(left, op, right)) = T :-\n        {T_Left} T_Left == okSingleExpression(s, typeClass, left),\n        {T_Right} T_Right == okSingleExpression(s, typeClass, right),\n        {T_Candidates} T_Candidates == typeOfBinaryDataMethods(s, OperatorBinary4(op)),\n        {T_Filtered_Candidates} T_Filtered_Candidates == filterCompatible(T_Candidates, T_Left, [T_Right]),\n        try { T_Filtered_Candidates == [_|_] } | warning $[No method with compatible parameter types],\n        T == gcaList(getDataMethodReturnTypes(T_Filtered_Candidates)).\n    okSingleExpression(s, typeClass, DataMethodCallExpression(expr, onSuperClass, name, optParameters)) = T :-\n        {T_Expr} T_Expr == okSingleExpression(s, typeClass, expr),\n        {T_Target} T_Target == okOnSuperClass(T_Expr, onSuperClass),\n        {T_Parameters} T_Parameters == okExpressions(s, typeClass, stripOptExpressionList(optParameters)),\n        {T_Candidates} T_Candidates == typeOfNamedDataMethods(s, name, lengthDataClasses(T_Parameters)),\n        {T_Filtered_Candidates} T_Filtered_Candidates == filterCompatible(T_Candidates, T_Target, T_Parameters),\n        try { T_Filtered_Candidates == [_|_] } | warning $[No method with compatible parameter types],\n        T == gcaList(getDataMethodReturnTypes(T_Filtered_Candidates)).\n    okSingleExpression(s, typeClass, UnaryOperatorExpression(op, expr)) = T :-\n        {T_Expr} T_Expr == okSingleExpression(s, typeClass, expr),\n        {T_Candidates} T_Candidates == typeOfUnaryDataMethods(s, op),\n        {T_Filtered_Candidates} T_Filtered_Candidates == filterCompatible(T_Candidates, T_Expr, []),\n        try { T_Filtered_Candidates == [_|_] } | warning $[No method with compatible parameter types],\n        T == gcaList(getDataMethodReturnTypes(T_Filtered_Candidates)).\n    okSingleExpression(s, typeClass, IfThenExpression(condition, thenClause)) = typeOfDataClassNoRef(s, \"Object\") :-\n        {T_Condition} T_Condition == okExpression(s, typeClass, condition),\n        {T_Then} T_Then == okExpression(s, typeClass, thenClause),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleExpression(s, typeClass, IfThenElseExpression(condition, thenClause, elseClause)) = gca(T_Then, T_Else) :-\n        {T_Condition} T_Condition == okExpression(s, typeClass, condition),\n        T_Then == okExpression(s, typeClass, thenClause),\n        T_Else == okExpression(s, typeClass, elseClause),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleExpression(s, typeClass, WhileExpression(condition, body)) = typeOfDataClass(s, \"Object\") :-\n        {T_Condition} T_Condition == okExpression(s, typeClass, condition),\n        {T_Body} T_Body == okExpression(s, typeClass, body),\n        try { compatibleType(T_Condition, typeOfDataClassNoRef(s, \"Boolean\")) } | warning $[Incompatible type] @condition.\n    okSingleExpression(s, typeClass, SwitchExpression(expr, CaseExpressionList(cases), default)) = T :-\n        try { nonEmptySwitchExpression(cases, default) } | warning $[Missing case or default],\n        {T_Expr} T_Expr == okExpression(s, typeClass, expr),\n        {T_Default} T_Default == okOptDefaultExpression(s, typeClass, default),\n        T == okCaseExpressions(s, typeClass, cases, T_Expr, T_Default).\n    okSingleExpression(s, typeClass, CurrentTimeExpression()) =         typeOfDataClassNoRef(s, \"Real\").\n    okSingleExpression(s, typeClass, SelfExpression()) =                typeClass.\n    okSingleExpression(s, typeClass, ConstantExpression(expr)) =        okConstantExpression(s, expr).\n    okSingleExpression(s, typeClass, NewExpression(class)) =            typeOfDataClass(s, class).\n    okSingleExpression(s, typeClass, VariableExpression(var)) =         typeOfVariable(s, var).\n    okSingleExpression(s, typeClass, RoundBracketExpression(expr)) =    okExpression(s, typeClass, expr).\n\n    okConstantExpression : scope * ExpressionConstant -&gt; TypeDataClass\n    okConstantExpression(s, BooleanConstant(value)) =       typeOfDataClassNoRef(s, \"Boolean\").\n    okConstantExpression(s, CharacterConstant(value)) =     typeOfDataClassNoRef(s, \"Char\").\n    okConstantExpression(s, FloatConstant(value)) =         typeOfDataClassNoRef(s, \"Real\").\n    okConstantExpression(s, IntegerConstant(value)) =       typeOfDataClassNoRef(s, \"Integer\").\n    okConstantExpression(s, NilConstant()) =                typeOfDataClassNoRef(s, \"Object\").\n    okConstantExpression(s, RealConstant(value)) =          typeOfDataClassNoRef(s, \"Real\").\n    okConstantExpression(s, StringConstant(value)) =        typeOfDataClassNoRef(s, \"String\").\n    okConstantExpression(s, EnvironmentConstant(value)) =   typeOfDataClassNoRef(s, \"Object\").\n\n    okOnSuperClass : TypeDataClass * OnSuperClass -&gt; TypeDataClass\n    okOnSuperClass(tc, NotOnSuperClass()) = tc.\n    okOnSuperClass(TypeDataClassRoot(), OnSuperClass()) = TypeDataClassRoot().\n    okOnSuperClass(TypeDataClass(s, e), OnSuperClass()) = e.\n\n    okOptDefaultExpression : scope * TypeDataClass * OptDefaultExpression -&gt; TypeDataClass\n    okOptDefaultExpression(s, typeClass, DefaultExpression(expr)) =     okExpression(s, typeClass, expr).\n    okOptDefaultExpression(s, typeClass, NoDefaultExpression()) =       typeOfDataClassNoRef(s, \"Object\").\n\n    okCaseExpressions : scope * TypeDataClass * list(CaseExpression) * TypeDataClass * TypeDataClass -&gt; TypeDataClass\n    okCaseExpressions(s, typeClass, [], T_Expr, T_Default) =        T_Default.\n    okCaseExpressions(s, typeClass, [case|cases], T_Expr, T_Base) = okCaseExpressions(s, typeClass, cases, T_Expr, gca(T_Base, okCaseExpression(s, typeClass, case, T_Expr))).\n\n    okCaseExpression : scope * TypeDataClass * CaseExpression * TypeDataClass -&gt; TypeDataClass\n    okCaseExpression(s, typeClass, CaseExpression(condition, body), T_Expr) = T_Body :-\n        {T_Condition} T_Condition == okExpression(s, typeClass, condition),\n        try { compatibleType(T_Condition, T_Expr) } | warning $[Incompatible type] @condition,\n        T_Body == okExpression(s, typeClass, body).\n\nrules   // === Non-empty switch  =======\n\n    nonEmptySwitchExpression : list(CaseExpression) * OptDefaultExpression\n    nonEmptySwitchExpression([C|Cs], _).\n    nonEmptySwitchExpression(_, DefaultExpression(s)).\n\n    nonEmptySwitchStatement : list(CaseStatement) * OptDefaultStatement\n    nonEmptySwitchStatement([C|Cs], _).\n    nonEmptySwitchStatement(_, DefaultStatement(s)).\n\nrules   // === Getters on TypeDataMethod =======\n\n    getDataMethodReturnTypes maps getDataMethodReturnType(list(*)) = list(*)\n    getDataMethodReturnType : TypeDataMethod -&gt; TypeDataClass\n    getDataMethodReturnType(TypeDataMethod(receiver, args, retType)) = retType.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-expr-stat.stx/#modal-h2","title":"statics-expr-stat.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-names.stx/","title":"<code>statics-names.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-names.stx</p> <pre><code>module statics-names\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n\nsignature\n\n    name-resolution\n        labels P // Parent\n        labels I // Inheritance\n        // $ = local scope\n\n    sorts TypeProcessOrClusterClass constructors\n        TypeClusterClass : scope -&gt; TypeProcessOrClusterClass\n        TypeProcessClassRoot : TypeProcessOrClusterClass\n        TypeProcessClass : scope * scope -&gt; TypeProcessOrClusterClass\n\n    sorts TypeDataClass constructors\n        TypeDataClassRoot : TypeDataClass\n        TypeDataClass : scope * TypeDataClass -&gt; TypeDataClass\n\n    sorts TypeProcessMethod constructors\n        TypeProcessMethod : list(TypeDataClass) * list(TypeDataClass) -&gt; TypeProcessMethod\n\n    sorts TypeDataMethod constructors\n        TypeDataMethod : TypeDataClass * list(TypeDataClass) * TypeDataClass -&gt; TypeDataMethod\n\n    sorts TypeMessage constructors\n        TypeMessage : list(TypeDataClass) -&gt; TypeMessage\n\n    relations\n        varProcessOrClusterClass : string -&gt; TypeProcessOrClusterClass\n        varDataClass : string -&gt; TypeDataClass\n        varProcessMethod : (string * int * int) -&gt; TypeProcessMethod\n        varDataMethodNamed : (string * string * int) -&gt; TypeDataMethod\n        varDataMethodUnary: (string * UnaryOperator * int) -&gt; TypeDataMethod\n        varDataMethodBinary : (string * OperatorBinary * int) -&gt; TypeDataMethod\n        varReceiveMessage : (string * string * int) -&gt; TypeMessage\n        varSendMessage : (string * string * int) -&gt; TypeMessage\n    relations\n        varInstance : string -&gt; TypeProcessOrClusterClass\n        varPort : string\n        varVariable : string -&gt; TypeDataClass\n\nrules // --- ProcessOrClusterClass -------\n\n    resolveProcessOrClusterClass : scope * string -&gt; list((path * (string * TypeProcessOrClusterClass)))\n    resolveProcessOrClusterClass(s, x) = ps :-\n        query varProcessOrClusterClass\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareProcessOrClusterClass : scope * string * TypeProcessOrClusterClass\n    declareProcessOrClusterClass(s, x, T) :-\n        !varProcessOrClusterClass[x, T] in s,\n        resolveProcessOrClusterClass(s, x) == [(_, (_, _))] | error $[Duplicate definition of process or cluster class [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfProcessOrClusterClass : scope * string -&gt; TypeProcessOrClusterClass\n    typeOfProcessOrClusterClass(s, x) = T :- {x'} @x.ref := x',\n        resolveProcessOrClusterClass(s, x) == [(_,(x', T))|_] | error $[Process or cluster class [x] not defined].\n\nrules // --- DataClass -------\n\n    resolveDataClass : scope * string -&gt; list((path * (string * TypeDataClass)))\n    resolveDataClass(s, x) = ps :-\n        query varDataClass\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareDataClass : scope * string * TypeDataClass\n    declareDataClass(s, x, T) :-\n        !varDataClass[x, T] in s,\n        resolveDataClass(s, x) == [(_, (_, _))] | error $[Duplicate definition of data class [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfDataClasses maps typeOfDataClass(*, list(*)) = list(*)\n    typeOfDataClass : scope * string -&gt; TypeDataClass\n    typeOfDataClass(s, x) = T :- {x'} @x.ref := x',\n        resolveDataClass(s, x) == [(_,(x', T))|_] | error $[Data class [x] not defined].\n\n    typeOfDataClassNoRef : scope * string -&gt; TypeDataClass\n    typeOfDataClassNoRef(s, x) = T :- {x'}\n        resolveDataClass(s, x) == [(_,(x', T))|_] | error $[Data class [x] not defined].\n\nrules // --- ProcessMethod -------\n\n    resolveProcessMethod : scope * (string * int * int) -&gt; list((path * ((string * int * int) * TypeProcessMethod)))\n    resolveProcessMethod(s, x) = ps :-\n        query varProcessMethod\n            filter P* I* and { x' :- x' == x }\n            min /* Label order: */ $ &lt; P, $ &lt; I, P &lt; I and /* Shadow: */ true // prefer P over I\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareProcessMethod : scope * string * TypeProcessMethod\n    declareProcessMethod(s, x, T) :-\n        {inArgs outArgs} T == TypeProcessMethod(inArgs, outArgs),\n        {i j} i == lengthDataClasses(inArgs), j == lengthDataClasses(outArgs),\n        !varProcessMethod[(x, i, j), T] in s,\n        resolveProcessMethod(s, (x, i, j)) == [(_, (_, _))] | error $[Duplicate definition of process method [x] with [i] input argument(s) and [j] input argument(s)],\n        @x.type := T, @x.decl := x.\n\n    typeOfProcessMethod : scope * string * int * int -&gt; TypeProcessMethod\n    typeOfProcessMethod(s, x, i, j) = T :- {x' i' j'} @x.ref := x',\n        resolveProcessMethod(s, (x, i, j)) == [(_,((x', i', j'), T))|_] | error $[Process method [x] with [i] input argument(s) and [j] input argument(s) not defined].\n\nrules // --- NamedDataMethod -------\n\n    resolveNamedDataMethod : scope * (string * string * int) -&gt; list((path * ((string * string * int) * TypeDataMethod)))\n    resolveNamedDataMethod(s, x) = ps :-\n        query varDataMethodNamed\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    resolveNamedDataMethodPartial : scope * string * int -&gt; list((path * ((string * string * int) * TypeDataMethod)))\n    resolveNamedDataMethodPartial(s, x, i) = ps :-\n        query varDataMethodNamed\n            filter P* and { (c', x', i') :- (x', i') == (x, i) }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareNamedDataMethod : scope * string * string * TypeDataMethod\n    declareNamedDataMethod(s, c, x, T) :-\n        {receiver args retType} T == TypeDataMethod(receiver, args, retType),\n        {i} i == lengthDataClasses(args),\n        !varDataMethodNamed[(c, x, i), T] in s,\n        resolveNamedDataMethod(s, (c, x, i)) == [(_, (_, _))] | error $[Duplicate definition of named data method [x] with [i] argument(s)],\n        @x.type := T, @x.decl := x.\n\n    typeOfNamedDataMethods : scope * string * int -&gt; list(TypeDataMethod)\n    typeOfNamedDataMethods(s, x, i) = getTypeNamedDataMethods([T|Ts]) :-\n        resolveNamedDataMethodPartial(s, x, i) == [T|Ts] | error $[Named data method [x] with [i] argument(s) not defined].\n\n    getTypeNamedDataMethods maps getTypeNamedDataMethod(list(*)) = list(*)\n    getTypeNamedDataMethod : (path * ((string * string * int) * TypeDataMethod)) -&gt; TypeDataMethod\n    getTypeNamedDataMethod((p, (_, t))) = t.\n\nrules // --- UnaryDataMethod -------\n\n    resolveUnaryDataMethod : scope * (string * UnaryOperator * int) -&gt; list((path * ((string * UnaryOperator * int) * TypeDataMethod)))\n    resolveUnaryDataMethod(s, x) = ps :-\n        query varDataMethodUnary\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    resolveUnaryDataMethodPartial : scope * UnaryOperator * int -&gt; list((path * ((string * UnaryOperator * int) * TypeDataMethod)))\n    resolveUnaryDataMethodPartial(s, x, i) = ps :-\n        query varDataMethodUnary\n            filter P* and { (c', x', i') :- (x', i') == (x, i) }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareUnaryDataMethod : scope * string * UnaryOperator * TypeDataMethod\n    declareUnaryDataMethod(s, c, x, T) :-\n        {receiver args retType} T == TypeDataMethod(receiver, args, retType),\n        {i} i == lengthDataClasses(args),\n        !varDataMethodUnary[(c, x, i), T] in s,\n        resolveUnaryDataMethod(s, (c, x, i)) == [(_, (_, _))] | error $[Duplicate definition of unary data method [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfUnaryDataMethods : scope * UnaryOperator -&gt; list(TypeDataMethod)\n    typeOfUnaryDataMethods(s, x) = getTypeUnaryDataMethods([T|Ts]) :-\n        resolveUnaryDataMethodPartial(s, x, 0) == [T|Ts] | error $[Unary data method [x] not defined].\n\n    getTypeUnaryDataMethods maps getTypeUnaryDataMethod(list(*)) = list(*)\n    getTypeUnaryDataMethod : (path * ((string * UnaryOperator * int) * TypeDataMethod)) -&gt; TypeDataMethod\n    getTypeUnaryDataMethod((p, (_, t))) = t.\n\nrules // --- BinaryDataMethod -------\n\n    resolveBinaryDataMethod : scope * (string * OperatorBinary * int) -&gt; list((path * ((string * OperatorBinary * int) * TypeDataMethod)))\n    resolveBinaryDataMethod(s, x) = ps :-\n        query varDataMethodBinary\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    resolveBinaryDataMethodPartial : scope * OperatorBinary * int -&gt; list((path * ((string * OperatorBinary * int) * TypeDataMethod)))\n    resolveBinaryDataMethodPartial(s, x, i) = ps :-\n        query varDataMethodBinary\n            filter P* and { (c', x', i') :- (x', i') == (x, i) }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareBinaryDataMethod : scope * string * OperatorBinary * TypeDataMethod\n    declareBinaryDataMethod(s, c, x, T) :-\n        {receiver args retType} T == TypeDataMethod(receiver, args, retType),\n        {i} i == lengthDataClasses(args),\n        !varDataMethodBinary[(c, x, i), T] in s,\n        resolveBinaryDataMethod(s, (c, x, i)) == [(_, (_, _))] | error $[Duplicate definition of binary data method [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfBinaryDataMethods : scope * OperatorBinary -&gt; list(TypeDataMethod)\n    typeOfBinaryDataMethods(s, x) = getTypeBinaryDataMethods([T|Ts]) :-\n        resolveBinaryDataMethodPartial(s, x, 1) == [T|Ts] | error $[Binary data method [x] not defined].\n\n    getTypeBinaryDataMethods maps getTypeBinaryDataMethod(list(*)) = list(*)\n    getTypeBinaryDataMethod : (path * ((string * OperatorBinary * int) * TypeDataMethod)) -&gt; TypeDataMethod\n    getTypeBinaryDataMethod((p, (_, t))) = t.\n\n\nrules // --- ReceiveMessage -------\n\n    resolveReceiveMessage : scope * (string * string * int) -&gt; list((path * ((string * string * int) * TypeMessage)))\n    resolveReceiveMessage(s, x) = ps :-\n        query varReceiveMessage\n            filter P* I* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareReceiveMessage : scope * string * string * TypeMessage\n    declareReceiveMessage(s, p, m, T) :-\n        {args} T == TypeMessage(args),\n        {i} i == lengthDataClasses(args),\n        !varReceiveMessage[(p, m, i), T] in s,\n        resolveReceiveMessage(s, (p, m, i)) == [(_, (_, _))] | error $[Duplicate definition of receive message [p].[m] with [i] argument(s)],\n        @m.type := T, @m.decl := m.\n\n    typeOfReceiveMessage : scope * string * string * int -&gt; TypeMessage\n    typeOfReceiveMessage(s, p, m, i) = T :- {p' m' i'} @m.ref := m',\n        resolveReceiveMessage(s, (p, m, i)) == [(_,((p', m', i'), T))|_] | error $[Receive message [p].[m] with [i] argument(s) not defined].\n\nrules // --- SendMessage -------\n\n    resolveSendMessage : scope * (string * string * int) -&gt; list((path * ((string * string * int) * TypeMessage)))\n    resolveSendMessage(s, x) = ps :-\n        query varSendMessage\n            filter P* I* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareSendMessage : scope * string * string * TypeMessage\n    declareSendMessage(s, p, m, T) :-\n        {args} T == TypeMessage(args),\n        {i} i == lengthDataClasses(args),\n        !varSendMessage[(p, m, i), T] in s,\n        resolveSendMessage(s, (p, m, i)) == [(_, (_, _))] | error $[Duplicate definition of send message [p].[m] with [i] argument(s)],\n        @m.type := T, @m.decl := m.\n\n    typeOfSendMessage : scope * string * string * int -&gt; TypeMessage\n    typeOfSendMessage(s, p, m, i) = T :- {p' m' i'} @m.ref := m',\n        resolveSendMessage(s, (p, m, i)) == [(_,((p', m', i'), T))|_] | error $[Send message [p].[m] with [i] argument(s) not defined].\n\nrules // --- Instance -------\n\n    resolveInstance : scope * string -&gt; list((path * (string * TypeProcessOrClusterClass)))\n    resolveInstance(s, x) = ps :-\n        query varInstance\n            filter P* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareInstance : scope * string * TypeProcessOrClusterClass\n    declareInstance(s, x, T) :-\n        !varInstance[x, T] in s,\n        resolveInstance(s, x) == [(_, (_, _))] | error $[Duplicate definition of instance [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfInstance : scope * string -&gt; TypeProcessOrClusterClass\n    typeOfInstance(s, x) = T :- {x'} @x.ref := x',\n        resolveInstance(s, x) == [(_,(x', T))|_] | error $[Instance [x] not defined].\n\nrules // --- Port -------\n\n    resolvePort : scope * string -&gt; list((path * string))\n    resolvePort(s, x) = ps :-\n        query varPort\n            filter P* I* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declarePort : scope * string\n    declarePort(s, x) :-\n        !varPort[x] in s,\n        resolvePort(s, x) == [(_, _)] | error $[Duplicate definition of port [x]],\n        @x.decl := x.\n\n    typeOfPort : scope * string\n    typeOfPort(s, x) :- {x'} @x.ref := x',\n        resolvePort(s, x) == [(_,x')|_] | error $[Port [x] not defined].\n\nrules // --- Variable -------\n\n    resolveVariable : scope * string -&gt; list((path * (string * TypeDataClass)))\n    resolveVariable(s, x) = ps :-\n        query varVariable\n            filter P* I* and { x' :- x' == x }\n            min /* Label order: */ and /* Shadow: */ true\n            in /* Scope: */ s |-&gt; /* Result: */ ps.\n\n    declareVariables maps declareVariable(*, list(*), *)\n    declareVariable : scope * string * TypeDataClass\n    declareVariable(s, x, T) :-\n        !varVariable[x, T] in s,\n        resolveVariable(s, x) == [(_, (_, _))] | error $[Duplicate definition of variable [x]],\n        @x.type := T, @x.decl := x.\n\n    typeOfVariables maps typeOfVariable(*, list(*)) = list(*)\n    typeOfVariable : scope * string -&gt; TypeDataClass\n    typeOfVariable(s, x) = T :- {x'} @x.ref := x',\n        resolveVariable(s, x) == [(_,(x', T))|_] | error $[Variable [x] not defined].\n\nrules   // === List operations on TypeDataClass =======\n\n    concatDataClasses : list(TypeDataClass) * list(TypeDataClass) -&gt; list(TypeDataClass)\n    concatDataClasses([], ds2) = ds2.\n    concatDataClasses([d1|ds1], ds2) = [d1|concatDataClasses(ds1, ds2)]. \n\n    flattenDataClasses : list(list(TypeDataClass)) -&gt; list(TypeDataClass)\n    flattenDataClasses([]) = [].\n    flattenDataClasses([d|ds]) = concatDataClasses(d, flattenDataClasses(ds)).\n\n    lengthDataClasses: list(TypeDataClass) -&gt; int\n    lengthDataClasses([]) = 0.\n    lengthDataClasses([_|t]) = len :- {t_len}\n      t_len == lengthDataClasses(t),\n      len #= t_len + 1.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-names.stx/#modal-h2","title":"statics-names.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-opt.stx/","title":"<code>statics-opt.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-opt.stx</p> <pre><code>module statics-opt\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n\nrules   // === Strip optional lists =======\n\n    stripOptExpressionList : OptExpressionList -&gt; list(Expression)\n    stripOptExpressionList(NoExpressions()) = [].\n    stripOptExpressionList(Expressions(exprs)) = exprs.\n\n    stripOptInstanceParameterList : OptInstanceParameterList -&gt; list(InstanceParameter)\n    stripOptInstanceParameterList(NoInstanceParameters()) = [].\n    stripOptInstanceParameterList(InstanceParameters(parameters)) = parameters.\n\n    stripOptLocalVariablesList : OptLocalVariableList -&gt; list(Declaration)\n    stripOptLocalVariablesList(NoLocalVariables()) = [].\n    stripOptLocalVariablesList(LocalVariables(declarations)) = declarations.\n\n    stripOptParameterList : OptParameterList -&gt; list(Declaration)\n    stripOptParameterList(NoParameters()) = [].\n    stripOptParameterList(Parameters(declarations)) = declarations.\n\n    stripOptVariableList : OptVariableList -&gt; list(string)\n    stripOptVariableList(NoVariables()) = [].\n    stripOptVariableList(Variables(vars)) = vars.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-opt.stx/#modal-h2","title":"statics-opt.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics-typing.stx/","title":"<code>statics-typing.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics-typing.stx</p> <pre><code>module statics-typing\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n    statics-bool\n    statics-names\n\nrules   // === Are compatible =======\n\n    // public\n    compatibleTypes maps compatibleType(list(*), list(*))\n    compatibleType : TypeDataClass * TypeDataClass\n    compatibleType(T1, T2) :- boolCompatibleType(T1, T2) == TRUE().\n\n    // private\n    boolCompatibleTypes maps boolCompatibleType(list(*), list(*)) = list(*)\n    boolCompatibleType : TypeDataClass * TypeDataClass -&gt; TYPE_BOOL\n    boolCompatibleType(T1, T2) = or(subType(T1, T2), subType(T2, T1)).\n\nrules   // === Filter compatible =======\n\n    // public\n    filterCompatible : list(TypeDataMethod) * TypeDataClass * list(TypeDataClass) -&gt; list(TypeDataMethod)\n    filterCompatible(Ts, target, pars) = filterDataMethods(Ts, inputCompatibles(Ts, target, pars)). \n\n    // private\n    filterDataMethods: list(TypeDataMethod) * list(TYPE_BOOL) -&gt; list(TypeDataMethod)\n    filterDataMethods([], []) = [].\n    filterDataMethods([M|Ms], [TRUE()|Bs]) = [M|filterDataMethods(Ms, Bs)].\n    filterDataMethods([M|Ms], [FALSE()|Bs]) = filterDataMethods(Ms, Bs).\n\n    // private\n    inputCompatibles maps inputCompatible(list(*), *, *) = list(*)\n    inputCompatible : TypeDataMethod * TypeDataClass * list(TypeDataClass) -&gt; TYPE_BOOL\n    inputCompatible(TypeDataMethod(receiver, args, _), target, pars) = forall(boolCompatibleTypes([receiver|args], [target|pars])).\n\nrules   // === Subtype  =======\n\n    // private\n    subType : TypeDataClass * TypeDataClass -&gt; TYPE_BOOL\n    subType(T1, TypeDataClassRoot()) = TRUE().\n    subType(TypeDataClassRoot(), TypeDataClass(_,  _)) = FALSE().\n    subType(TypeDataClass(s, T), TypeDataClass(s, T))  = TRUE().\n    subType(TypeDataClass(_, ST1), T2) = subType(ST1, T2).\n\nrules   // === Greatest Common Ancestor =======\n\n    // public\n    gcaList : list(TypeDataClass) -&gt; TypeDataClass\n    gcaList([T|Ts]) = gcaListImpl(T, Ts).\n    gcaList([]) = TypeDataClassRoot().      // Only defined to avoid follow-up errors\n\n    // private\n    gcaListImpl : TypeDataClass * list(TypeDataClass) -&gt; TypeDataClass\n    gcaListImpl(G, []) = G.\n    gcaListImpl(G, [T|Ts]) = gcaListImpl(gca(G, T), Ts).\n\n    // public\n    gca : TypeDataClass * TypeDataClass -&gt; TypeDataClass\n    gca(T1, T2) = lastTDC(largestCommonPrefixTDC(reverseAncestors(T1), reverseAncestors(T2))).\n\nrules\n\n    // private\n    reverseAncestors : TypeDataClass -&gt; list(TypeDataClass)\n    reverseAncestors(T) = reverseAncestorsImpl(T, []).\n\n    // private  \n    reverseAncestorsImpl : TypeDataClass * list(TypeDataClass) -&gt; list(TypeDataClass)\n    reverseAncestorsImpl(TypeDataClassRoot(), Rs) = Rs.\n    reverseAncestorsImpl(TypeDataClass(s, T), Rs) = reverseAncestorsImpl(T, [TypeDataClass(s, T) | Rs]).\n\nrules\n    // private\n    largestCommonPrefixTDC : list(TypeDataClass) * list(TypeDataClass) -&gt; list(TypeDataClass)\n    largestCommonPrefixTDC([T|xs], [T|ys]) = [T|largestCommonPrefixTDC(xs, ys)].\n    largestCommonPrefixTDC(xs, ys) = [].\n\n    // private\n    lastTDC : list(TypeDataClass) -&gt; TypeDataClass\n    lastTDC([x]) = x.\n    lastTDC([x|[y|zs]]) = lastTDC([y|zs]).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics-typing.stx/#modal-h2","title":"statics-typing.stx","text":""},{"location":"org.metaborg.lang.poosl/trans/statics.stx/","title":"<code>statics.stx</code>","text":"<p> pdmosses/metaborg-poosl/org.metaborg.lang.poosl/trans/statics.stx</p> <pre><code>module statics\n\nimports\n    signatures/Poosl-sig\n    signatures/Common-sig\n    statics-comm\n    statics-expr-stat\n    statics-typing\n    statics-opt\n    statics-names\n\n// see README.md for details on how to switch to multi-file analysis\n// TODO file-based imports (not namespace-based imports)\n\nrules // single-file entry point\n\n    programOk : Poosl\n    programOk(Poosl(ImportList(imports), ClassList(classes))) :- {s_poosl}\n        new s_poosl,\n        try { selectSystemClasses(classes) == [_|[]] } | error $[There should be exactly 1 system class],\n        okClasses(s_poosl, classes).\n\nrules // multi-file entry point\n\n    projectOk : scope\n    projectOk(s).\n\n    fileOk : scope * Poosl\n    fileOk(s, Poosl(ImportList(imports), ClassList(classes))) :- {s_poosl}\n        new s_poosl, s_poosl -P-&gt; s,\n        try { selectSystemClasses(classes) == [_|[]] } | error $[There should be exactly 1 system class],\n        okClasses(s_poosl, classes).\n\nrules // === Classes ( -P-&gt; ) =======\n\n    okClasses maps okClass(*, list(*))\n    okClass : scope * Class\n    okClass(s, DataClass(AnnotationList(annotations), nativeClause, name, extendsClause, DeclarationOptCommaList(variables), DataMethodList(methods))) :-\n        {s_internal} new s_internal, s_internal -P-&gt; s,             // variables, methods\n        {T_extends} T_extends == okExtendsClauseDataClass(s_internal, name, extendsClause), \n        declareDataClass(s, name, TypeDataClass(s_internal, T_extends)),\n        okDeclarationOptCommas(s_internal, variables),\n        okDataMethods(s, s_internal, name, TypeDataClass(s_internal, T_extends), methods).\n\n    okClass(s, ProcessClass(AnnotationList(annotations), name, optParameters, extendsClause, PortList(ports), MessageSignatureList(messages), DeclarationOptCommaList(variables), initMethodCall, ProcessMethodList(methods))) :-\n        {s_external} new s_external, s_external -P-&gt; s,             // parameters, ports, messages\n        {s_internal} new s_internal, s_internal -P-&gt; s_external,    // variables, methods\n        okExtendsClauseProcessClass(s_external, s_internal, extendsClause),\n        declareProcessOrClusterClass(s, name, TypeProcessClass(s_external, s_internal)),\n        okDeclarations(s_external, stripOptParameterList(optParameters)) == _,\n        okPorts(s_external, ports),\n        okMessageSignatures(s_external, messages),\n        okDeclarationOptCommas(s_internal, variables),\n        okProcessMethodCall(s_internal, initMethodCall),\n        okProcessMethods(s_internal, methods).\n\n    okClass(s, ClusterClass(AnnotationList(annotations), name, optParameters, PortList(ports), InstanceList(instances), ChannelList(channels))) :-\n        {s_external} new s_external, s_external -P-&gt; s,             // parameters, ports\n        {s_internal} new s_internal, s_internal -P-&gt; s_external,    // instances, channels\n        declareProcessOrClusterClass(s, name, TypeClusterClass(s_external)),\n        okDeclarations(s_external, stripOptParameterList(optParameters)) == _,\n        okPorts(s_external, ports),\n        okInstances(s_internal, instances),\n        okChannels(s_internal, channels).\n\n    okClass(s, System(AnnotationList(annotations), InstanceList(instances), ChannelList(channels))) :-\n        {s_internal} new s_internal, s_internal -P-&gt; s,             // instances, channels\n        okInstances(s_internal, instances),\n        okChannels(s_internal, channels).\n\n// Note: no scopes associated to ports (for the related message signatures), because of inheritance.\n\nrules // === Class extends clauses ( -I-&gt; ) =======\n\n    okExtendsClauseDataClass : scope * string * ExtendsClause -&gt; TypeDataClass\n    okExtendsClauseDataClass(s_internal, \"Object\", _) = TypeDataClassRoot().\n    okExtendsClauseDataClass(s_internal, _, NoExtends()) = TypeDataClass(s2_internal, T_extends) :-\n        TypeDataClass(s2_internal, T_extends) == typeOfDataClassNoRef(s_internal, \"Object\"),\n        s_internal -I-&gt; s2_internal.\n    okExtendsClauseDataClass(s_internal, _, Extends(name)) = TypeDataClass(s2_internal, T_extends) :-\n        TypeDataClass(s2_internal, T_extends) == typeOfDataClass(s_internal, name),\n        s_internal -I-&gt; s2_internal.\n\n    okExtendsClauseProcessClass : scope * scope * ExtendsClause\n    okExtendsClauseProcessClass(s_external, s_internal, NoExtends()).\n    okExtendsClauseProcessClass(s_external, s_internal, Extends(name)) :-\n        {s2_external s2_internal} TypeProcessClass(s2_external, s2_internal) == typeOfProcessOrClusterClass(s_internal, name),\n        s_external -I-&gt; s2_external,\n        s_internal -I-&gt; s2_internal.\n\nrules // === Methods ( -P-&gt; ) =======\n\n    okProcessMethods maps okProcessMethod(*, list(*))\n    okProcessMethod : scope * ProcessMethod\n    okProcessMethod(s_internal, ProcessMethod(AnnotationList(annotations), name, ParameterList(inParameters), ParameterList(outParameters), optLocalVariables, body)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typesInputParameters} typesInputParameters == okDeclarations(s_method, inParameters),\n        {typesOutputParameters} typesOutputParameters == okDeclarations(s_method, outParameters),\n        declareProcessMethod(s_internal, name, TypeProcessMethod(flattenDataClasses(typesInputParameters), flattenDataClasses(typesOutputParameters))),\n        okDeclarations(s_method, stripOptLocalVariablesList(optLocalVariables)) == _,\n        okStatement(s_method, body).\n\n    okDataMethods maps okDataMethod(*, *, *, *, list(*))\n    okDataMethod : scope * scope * string * TypeDataClass * DataMethod\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodNamed(AnnotationList(annotations), name, optParameters, returnType, optLocalVariables, body)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typesInputParameters} typesInputParameters == flattenDataClasses(okDeclarations(s_method, stripOptParameterList(optParameters))),\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareNamedDataMethod(s, cname, name, TypeDataMethod(typeClass, typesInputParameters, typeReturnValue)),\n        okDeclarations(s_method, stripOptLocalVariablesList(optLocalVariables)) == _,\n        {type_Body} type_Body == okExpression(s_method, typeClass, body),\n        try { compatibleType(type_Body, typeReturnValue) } | warning $[Incompatible type] @body.\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodUnary(AnnotationList(annotations), name, _, returnType, optLocalVariables, body)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareUnaryDataMethod(s, cname, name, TypeDataMethod(typeClass, [], typeReturnValue)),\n        okDeclarations(s_method, stripOptLocalVariablesList(optLocalVariables)) == _,\n        {type_Body} type_Body == okExpression(s_method, typeClass, body),\n        try { compatibleType(type_Body, typeReturnValue) } | warning $[Incompatible type] @body.\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodBinary(AnnotationList(annotations), name, parameter, returnType, optLocalVariables, body)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typesInputParameters} typesInputParameters == flattenDataClasses(okDeclarations(s_method, [parameter])),\n        try { [_|[]] == typesInputParameters } | error $[Expected only 1 argument] @parameter,\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareBinaryDataMethod(s, cname, name, TypeDataMethod(typeClass, typesInputParameters, typeReturnValue)),\n        okDeclarations(s_method, stripOptLocalVariablesList(optLocalVariables)) == _,\n        {type_Body} type_Body == okExpression(s_method, typeClass, body),\n        try { compatibleType(type_Body, typeReturnValue) } | warning $[Incompatible type] @body.\n\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodNamedNative(name, optParameters, returnType)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typesInputParameters} typesInputParameters == flattenDataClasses(okDeclarations(s_method, stripOptParameterList(optParameters))),\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareNamedDataMethod(s, cname, name, TypeDataMethod(typeClass, typesInputParameters, typeReturnValue)).\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodUnaryNative(name, _, returnType)) :-\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareUnaryDataMethod(s, cname, name, TypeDataMethod(typeClass, [], typeReturnValue)).\n    okDataMethod(s, s_internal, cname, typeClass, DataMethodBinaryNative(name, parameter, returnType)) :-\n        {s_method} new s_method, s_method -P-&gt; s_internal,\n        {typesInputParameters} typesInputParameters == flattenDataClasses(okDeclarations(s_method, [parameter])),\n        try { [_|[]] == typesInputParameters } | error $[Expected only 1 argument] @parameter,\n        {typeReturnValue} typeReturnValue == typeOfDataClass(s, returnType),\n        declareBinaryDataMethod(s, cname, name, TypeDataMethod(typeClass, typesInputParameters, typeReturnValue)).\n\nrules\n\n    selectSystemClasses : list(Class) -&gt; list(Class)\n    selectSystemClasses([]) = [].\n    selectSystemClasses([System(AnnotationList(annotations), instances, channels)|Cs]) = [System(AnnotationList(annotations), instances, channels)|selectSystemClasses(Cs)].\n    selectSystemClasses([_|Cs]) = selectSystemClasses(Cs).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.lang.poosl/trans/statics.stx/#modal-h2","title":"statics.stx","text":""}]}